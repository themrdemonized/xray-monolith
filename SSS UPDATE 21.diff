 src/Layers/xrRender/Blender_BmmD.cpp               | 107 ++++-
 src/Layers/xrRender/Blender_Model_EbB.cpp          |  10 +-
 .../xrRender/Blender_Recorder_StandartBinding.cpp  | 318 +++++++++++++++
 src/Layers/xrRender/Blender_tree.cpp               |  19 +
 src/Layers/xrRender/DetailManager.cpp              |  32 +-
 src/Layers/xrRender/DetailManager.h                |   8 +
 src/Layers/xrRender/FTreeVisual.cpp                |  47 +++
 src/Layers/xrRender/ResourceManager.cpp            |  19 +
 src/Layers/xrRender/Shader.cpp                     |   4 +
 src/Layers/xrRender/Shader.h                       |   2 +
 src/Layers/xrRender/SkeletonCustom.h               |   1 +
 src/Layers/xrRender/SkeletonX.cpp                  |  47 ++-
 src/Layers/xrRender/blenders/Blender_Recorder.h    |   1 +
 src/Layers/xrRender/dxRainRender.cpp               |  71 +++-
 src/Layers/xrRender/dxRainRender.h                 |   1 +
 src/Layers/xrRender/dxWallMarkArray.cpp            |  17 +
 src/Layers/xrRender/light.cpp                      |   5 +-
 src/Layers/xrRender/light.h                        |  10 +-
 src/Layers/xrRender/r__dsgraph_build.cpp           |  31 +-
 src/Layers/xrRender/r__dsgraph_render.cpp          | 101 ++++-
 src/Layers/xrRender/r__dsgraph_structure.h         |   8 +-
 src/Layers/xrRender/r__dsgraph_types.h             |   8 +
 src/Layers/xrRender/rendertarget_phase_blur.cpp    | 449 +++++++++++++++++++--
 src/Layers/xrRender/xrRender_console.cpp           | 158 +++++++-
 src/Layers/xrRender/xrRender_console.h             |  26 ++
 src/Layers/xrRenderDX10/Blender_Recorder_R3.cpp    |  12 +
 .../xrRenderDX10/DX10 Rain/dx10RainBlender.cpp     |   3 +
 src/Layers/xrRenderDX10/dx10DetailManager_VS.cpp   |  66 ++-
 .../xrRenderDX10/dx10ResourceManager_Resources.cpp |  12 +-
 .../xrRenderDX10/dx10ResourceManager_Scripting.cpp |  24 ++
 .../Light_Render_Direct_ComputeXFS.cpp             |  25 +-
 src/Layers/xrRenderPC_R4/blender_blur.cpp          | 286 ++++++++++++-
 src/Layers/xrRenderPC_R4/blender_blur.h            |  40 ++
 src/Layers/xrRenderPC_R4/blender_combine.cpp       |  66 ++-
 src/Layers/xrRenderPC_R4/blender_deffer_model.cpp  |   8 +-
 src/Layers/xrRenderPC_R4/blender_lut.cpp           |   6 +-
 src/Layers/xrRenderPC_R4/light_vis.cpp             |   5 +-
 src/Layers/xrRenderPC_R4/r2_R_lights.cpp           |  43 ++
 src/Layers/xrRenderPC_R4/r2_R_sun.cpp              |  11 +-
 src/Layers/xrRenderPC_R4/r2_types.h                |  32 +-
 src/Layers/xrRenderPC_R4/r4.cpp                    | 124 +++++-
 src/Layers/xrRenderPC_R4/r4.h                      |  12 +
 src/Layers/xrRenderPC_R4/r4_R_rain.cpp             |   7 +-
 src/Layers/xrRenderPC_R4/r4_R_render.cpp           |  23 +-
 src/Layers/xrRenderPC_R4/r4_loader.cpp             |   1 +
 src/Layers/xrRenderPC_R4/r4_rendertarget.cpp       |  54 ++-
 src/Layers/xrRenderPC_R4/r4_rendertarget.h         |  44 ++
 .../xrRenderPC_R4/r4_rendertarget_accum_direct.cpp |  23 +-
 .../xrRenderPC_R4/r4_rendertarget_accum_spot.cpp   |  89 +++-
 .../xrRenderPC_R4/r4_rendertarget_draw_rain.cpp    |   5 +-
 .../r4_rendertarget_phase_accumulator.cpp          |   8 +-
 .../r4_rendertarget_phase_combine.cpp              | 127 +++++-
 .../xrRenderPC_R4/r4_rendertarget_phase_ssao.cpp   | 283 +++++++++++++
 src/xrCore/xr_resource.h                           |   2 +
 src/xrEngine/Environment.cpp                       |  18 +
 src/xrEngine/Environment.h                         |   2 +
 src/xrEngine/Environment_misc.cpp                  |   5 +-
 src/xrEngine/IGame_Persistent.cpp                  | 310 ++++++++++++++
 src/xrEngine/IGame_Persistent.h                    |  38 ++
 src/xrEngine/Rain.cpp                              | 100 ++++-
 src/xrEngine/Rain.h                                |   5 +-
 src/xrEngine/Render.h                              |   1 +
 src/xrEngine/bone.h                                |   5 +
 src/xrEngine/xr_ioc_cmd.cpp                        |   3 +
 src/xrGame/CustomZone.cpp                          | 151 +++++++
 src/xrGame/CustomZone.h                            |  22 +
 src/xrGame/Explosive.cpp                           |   5 +
 src/xrGame/PHMovementControl.cpp                   |   5 +
 src/xrGame/Torch.cpp                               |   2 +
 src/xrGame/WeaponFire.cpp                          |   4 +
 .../burer/burer_state_attack_gravi_inline.h        |   4 +
 .../ai/monsters/pseudogigant/pseudo_gigant.cpp     |   4 +
 src/xrGame/level_script.cpp                        |  34 +-
 src/xrGame/movement_manager.cpp                    |   3 +
 src/xrGame/movement_manager.h                      |   4 +
 src/xrGame/player_hud.cpp                          |   6 +
 76 files changed, 3479 insertions(+), 193 deletions(-)

diff --git a/src/Layers/xrRender/Blender_BmmD.cpp b/src/Layers/xrRender/Blender_BmmD.cpp
index 02e36cb..ab6c619 100644
--- a/src/Layers/xrRender/Blender_BmmD.cpp
+++ b/src/Layers/xrRender/Blender_BmmD.cpp
@@ -215,6 +215,7 @@ void CBlender_BmmD::Compile(CBlender_Compile& C)
 	IBlender::Compile(C);
 	// codepath is the same, only the shaders differ
 	// ***only pixel shaders differ***
+	C.SH->flags.isLandscape = FALSE;
 	string256 mask;
 	strconcat(sizeof(mask), mask, C.L_textures[0].c_str(), "_mask");
 	bool z_prepass = ps_r2_ls_flags.test(R2FLAG_TERRAIN_PREPASS);
@@ -228,8 +229,19 @@ void CBlender_BmmD::Compile(CBlender_Compile& C)
 			C.r_ColorWriteEnable(false, false, false, false);
 			C.r_End();
 		}
-		
-		uber_deffer(C, true, "impl", "impl", false, oT2_Name[0] ? oT2_Name : 0, true, z_prepass);
+
+#if RENDER == R_R4
+		if (RImplementation.o.ssfx_terrain)
+		{
+			C.SH->flags.isLandscape = TRUE;
+			uber_deffer(C, true, "terrain", "terrain_high", false, oT2_Name[0] ? oT2_Name : 0, true, z_prepass);
+		}
+		else
+#endif
+		{
+			uber_deffer(C, true, "impl", "impl", false, oT2_Name[0] ? oT2_Name : 0, true, z_prepass);
+		}
+
 		if (z_prepass) C.RS.SetRS(D3DRS_ZFUNC, D3DCMP_EQUAL);
 		//C.r_Sampler		("s_mask",	mask);
 //C.r_Sampler		("s_lmap",	C.L_textures[1]);
@@ -257,6 +269,21 @@ void CBlender_BmmD::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_dn_b", strconcat(sizeof(mask), mask, oB_Name, "_bump"));
 		C.r_dx10Texture("s_dn_a", strconcat(sizeof(mask), mask, oA_Name, "_bump"));
 
+#if RENDER == R_R4
+		if (RImplementation.o.ssfx_terrain)
+		{
+			C.r_dx10Texture("s_height_r", strconcat(sizeof(mask), mask, oR_Name, "_height"));
+			C.r_dx10Texture("s_height_g", strconcat(sizeof(mask), mask, oG_Name, "_height"));
+			C.r_dx10Texture("s_height_b", strconcat(sizeof(mask), mask, oB_Name, "_height"));
+			C.r_dx10Texture("s_height_a", strconcat(sizeof(mask), mask, oA_Name, "_height"));
+		}
+#endif
+
+		C.r_dx10Texture("s_puddles_normal", "fx\\water_normal");
+		C.r_dx10Texture("s_puddles_perlin", "fx\\puddles_perlin");
+		C.r_dx10Texture("s_puddles_mask", strconcat(sizeof(mask), mask, C.L_textures[0].c_str(), "_puddles_mask"));
+		C.r_dx10Texture("s_rainsplash", "fx\\water_sbumpvolume");
+
 		C.r_dx10Sampler("smp_base");
 		C.r_dx10Sampler("smp_linear");
 
@@ -273,13 +300,47 @@ void CBlender_BmmD::Compile(CBlender_Compile& C)
 			C.r_ColorWriteEnable(false, false, false, false);
 			C.r_End();
 		}
-		
-		uber_deffer(C, false, "base", "impl", false, oT2_Name[0] ? oT2_Name : 0, true, z_prepass);
+
+#if RENDER == R_R4
+		if (RImplementation.o.ssfx_terrain)
+		{
+			C.SH->flags.isLandscape = TRUE;
+			uber_deffer(C, false, "base", "terrain_mid", false, oT2_Name[0] ? oT2_Name : 0, true, z_prepass);
+		}
+		else
+#endif
+		{
+			// Vanilla
+			uber_deffer(C, false, "base", "impl", false, oT2_Name[0] ? oT2_Name : 0, true, z_prepass);
+		}
+
 		if (z_prepass) C.RS.SetRS(D3DRS_ZFUNC, D3DCMP_EQUAL);
 
 		//C.r_Sampler		("s_lmap",	C.L_textures[1]);
 
-		C.r_dx10Texture("s_lmap", C.L_textures[1]);
+		
+		//C.r_dx10Texture("s_lmap", C.L_textures[1]);
+
+		C.r_dx10Texture("s_mask", mask);
+
+#if RENDER == R_R4
+		if (RImplementation.o.ssfx_terrain)
+		{
+			LPSTR LodTexture = strconcat(sizeof(mask), mask, C.L_textures[0].c_str(), "_lod_textures");
+			string_path fn;
+			if (FS.exist(fn, "$game_textures$", LodTexture, ".dds"))
+			{
+				C.r_dx10Texture("s_lod_texture", LodTexture);
+			}
+			else
+			{
+				C.r_dx10Texture("s_lod_texture", "terrain\\default_lod_textures");
+			}
+		}
+#endif
+
+		//C.r_dx10Texture("s_lmap", C.L_textures[1]);
+		C.r_dx10Sampler("smp_base");
 		C.r_dx10Sampler("smp_linear");
 
 
@@ -288,10 +349,44 @@ void CBlender_BmmD::Compile(CBlender_Compile& C)
 
 		C.r_End();
 		break;
+
+	case 3: // SSFX Low quality terrain
+
+		if (z_prepass)
+		{
+			C.SH->flags.bLandscape = TRUE;
+			C.r_Pass("shadow_direct_base", "shadow_direct_base", FALSE, TRUE, TRUE);
+			C.r_ColorWriteEnable(false, false, false, false);
+			C.r_End();
+		}
+
+		C.SH->flags.isLandscape = TRUE;
+
+		uber_deffer(C, false, "base", "terrain_low", false, oT2_Name[0] ? oT2_Name : 0, true, z_prepass);
+		if (z_prepass) C.RS.SetRS(D3DRS_ZFUNC, D3DCMP_EQUAL);
+
+		C.r_dx10Sampler("smp_linear");
+
+		C.r_Stencil(TRUE, D3DCMP_ALWAYS, 0xff, 0x7f, D3DSTENCILOP_KEEP, D3DSTENCILOP_REPLACE, D3DSTENCILOP_KEEP);
+		C.r_StencilRef(0x01);
+
+		C.r_End();
+		break;
+
 	case SE_R2_SHADOW: // smap
 //if (RImplementation.o.HW_smap)	C.r_Pass	("shadow_direct_base","dumb",	FALSE,TRUE,TRUE,FALSE);
 		//else							C.r_Pass	("shadow_direct_base","shadow_direct_base",FALSE);
-		C.r_Pass("shadow_direct_base", "dumb", FALSE,TRUE,TRUE,FALSE);
+#if RENDER == R_R4
+		if (RImplementation.o.ssfx_terrain)
+		{
+			C.r_Pass("shadow_direct_terrain", "dumb", FALSE, TRUE, TRUE, FALSE);
+		}
+		else
+#endif
+		{
+			// Vanilla
+			C.r_Pass("shadow_direct_base", "dumb", FALSE, TRUE, TRUE, FALSE);
+		}
 		//C.r_Sampler		("s_base",C.L_textures[0]);
 		C.r_dx10Texture("s_base", C.L_textures[0]);
 		C.r_dx10Sampler("smp_base");
diff --git a/src/Layers/xrRender/Blender_Model_EbB.cpp b/src/Layers/xrRender/Blender_Model_EbB.cpp
index ee4b9a9..8669ab3 100644
--- a/src/Layers/xrRender/Blender_Model_EbB.cpp
+++ b/src/Layers/xrRender/Blender_Model_EbB.cpp
@@ -223,7 +223,15 @@ void CBlender_Model_EbB::Compile(CBlender_Compile& C)
 		switch (C.iElement)
 		{
 		case SE_R2_NORMAL_HQ: // deffer
-			uber_deffer(C, true, "model", "base", false, 0, true);
+			
+			if (C.HudElement)
+			{
+				uber_deffer(C, true, "model_hud", "base_hud", false, 0, true);
+				C.r_dx10Texture("s_hud_rain", "fx\\hud_rain");
+			}
+			else
+				uber_deffer(C, true, "model", "base", false, 0, true);
+
 			C.r_Stencil(TRUE, D3DCMP_ALWAYS, 0xff, 0x7f, D3DSTENCILOP_KEEP, D3DSTENCILOP_REPLACE, D3DSTENCILOP_KEEP);
 			C.r_StencilRef(0x01);
 			C.r_End();
diff --git a/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp b/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
index 5035624..ef94556 100644
--- a/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
+++ b/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
@@ -384,6 +384,23 @@ class cl_hemi_color : public R_constant_setup
 };
 
 static cl_hemi_color binder_hemi_color;
+
+class cl_sky_color : public R_constant_setup
+{
+	u32 marker;
+	Fvector4 result;
+
+	virtual void setup(R_constant* C)
+	{
+		if (marker != Device.dwFrame)
+		{
+			CEnvDescriptor& desc = *g_pGamePersistent->Environment().CurrentEnv;
+			result.set(desc.sky_color.x, desc.sky_color.y, desc.sky_color.z, desc.sky_rotation);
+		}
+		RCache.set_c(C, result);
+	}
+};
+static cl_sky_color binder_sky_color;
 #endif
 
 static class cl_screen_res : public R_constant_setup
@@ -521,6 +538,42 @@ static class cl_near_far_plane : public R_constant_setup
 	}
 } binder_near_far_plane;
 
+// Screen Space Shaders Stuff
+extern float ps_ssfx_hud_hemi;
+extern Fvector4 ps_ssfx_il;
+extern Fvector4 ps_ssfx_il_setup1;
+extern Fvector4 ps_ssfx_ao;
+extern Fvector4 ps_ssfx_ao_setup1;
+extern Fvector4 ps_ssfx_water;
+extern Fvector4 ps_ssfx_water_setup1;
+extern Fvector4 ps_ssfx_water_setup2;
+
+extern Fvector4 ps_ssfx_volumetric;
+extern Fvector4 ps_ssfx_ssr_2;
+extern Fvector4 ps_ssfx_terrain_offset;
+
+extern Fvector3 ps_ssfx_shadow_bias;
+extern Fvector4 ps_ssfx_lut;
+extern Fvector4 ps_ssfx_wind_grass;
+extern Fvector4 ps_ssfx_wind_trees;
+
+extern Fvector4 ps_ssfx_florafixes_1;
+extern Fvector4 ps_ssfx_florafixes_2;
+
+extern float ps_ssfx_gloss_factor;
+extern Fvector3 ps_ssfx_gloss_minmax;
+
+extern Fvector4 ps_ssfx_wetsurfaces_1;
+extern Fvector4 ps_ssfx_wetsurfaces_2;
+
+extern int ps_ssfx_is_underground;
+extern Fvector4 ps_ssfx_lightsetup_1;
+extern Fvector4 ps_ssfx_hud_drops_1;
+extern Fvector4 ps_ssfx_hud_drops_2;
+extern Fvector4 ps_ssfx_blood_decals;
+extern Fvector4 ps_ssfx_wpn_dof_1;
+extern float ps_ssfx_wpn_dof_2;
+
 //Sneaky debug stuff
 extern Fvector4 ps_dev_param_1;
 extern Fvector4 ps_dev_param_2;
@@ -595,6 +648,238 @@ static class dev_param_8 : public R_constant_setup
 	}
 }    dev_param_8;
 
+static class ssfx_wpn_dof_1 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_wpn_dof_1.x, ps_ssfx_wpn_dof_1.y, ps_ssfx_wpn_dof_1.z, ps_ssfx_wpn_dof_1.w);
+	}
+}    ssfx_wpn_dof_1;
+
+static class ssfx_wpn_dof_2 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_wpn_dof_2, 0, 0, 0);
+	}
+}    ssfx_wpn_dof_2;
+
+static class ssfx_blood_decals : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_blood_decals);
+	}
+}    ssfx_blood_decals;
+
+static class ssfx_hud_drops_1 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_hud_drops_1);
+	}
+}    ssfx_hud_drops_1;
+
+static class ssfx_hud_drops_2 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_hud_drops_2);
+	}
+}    ssfx_hud_drops_2;
+
+static class ssfx_lightsetup_1 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_lightsetup_1);
+	}
+}    ssfx_lightsetup_1;
+
+static class ssfx_is_underground : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_is_underground, 0, 0, 0);
+	}
+}    ssfx_is_underground;
+
+static class ssfx_wetsurfaces_1 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_wetsurfaces_1);
+	}
+}    ssfx_wetsurfaces_1;
+
+static class ssfx_wetsurfaces_2 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_wetsurfaces_2);
+	}
+}    ssfx_wetsurfaces_2;
+
+static class ssfx_gloss : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_gloss_minmax.x, ps_ssfx_gloss_minmax.y, ps_ssfx_gloss_factor, 0);
+	}
+}    ssfx_gloss;
+
+static class ssfx_florafixes_1 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_florafixes_1);
+	}
+}    ssfx_florafixes_1;
+
+static class ssfx_florafixes_2 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_florafixes_2);
+	}
+}    ssfx_florafixes_2;
+
+static class ssfx_wind_grass : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_wind_grass);
+	}
+}    ssfx_wind_grass;
+
+static class ssfx_wind_trees : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_wind_trees);
+	}
+}    ssfx_wind_trees;
+
+static class ssfx_wind_anim : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, g_pGamePersistent->Environment().wind_anim);
+	}
+}    ssfx_wind_anim;
+
+static class ssfx_lut : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_lut);
+	}
+}    ssfx_lut;
+
+static class ssfx_shadow_bias : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_shadow_bias.x, ps_ssfx_shadow_bias.y, 0, 0);
+	}
+}    ssfx_shadow_bias;
+
+static class ssfx_terrain_offset : public R_constant_setup
+{
+	virtual void setup(R_constant * C)
+	{
+		RCache.set_c(C, ps_ssfx_terrain_offset);
+	}
+}    ssfx_terrain_offset;
+
+static class ssfx_ssr_2 : public R_constant_setup
+{
+	virtual void setup(R_constant * C)
+	{
+		RCache.set_c(C, ps_ssfx_ssr_2);
+	}
+}    ssfx_ssr_2;
+
+static class ssfx_volumetric : public R_constant_setup
+{
+	virtual void setup(R_constant * C)
+	{
+		RCache.set_c(C, ps_ssfx_volumetric);
+	}
+}    ssfx_volumetric;
+
+static class ssfx_water : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_water);
+	}
+}    ssfx_water;
+
+static class ssfx_water_setup1 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_water_setup1);
+	}
+}    ssfx_water_setup1;
+
+static class ssfx_water_setup2 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_water_setup2);
+	}
+}    ssfx_water_setup2;
+
+static class ssfx_ao : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_ao);
+	}
+}    ssfx_ao;
+
+static class ssfx_ao_setup1 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_ao_setup1);
+	}
+}    ssfx_ao_setup1;
+
+static class ssfx_il : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_il);
+	}
+}    ssfx_il;
+
+static class ssfx_il_setup1 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_il_setup1);
+	}
+}    ssfx_il_setup1;
+
+static class ssfx_hud_hemi : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_ssfx_hud_hemi, 0, 0, 0);
+	}
+}    ssfx_hud_hemi;
+
+static class ssfx_issvp : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, Device.m_SecondViewport.IsSVPFrame(), 0, 0, 0);
+	}
+}    ssfx_issvp;
+
 // Standart constant-binding
 void CBlender_Compile::SetMapping()
 {
@@ -680,6 +965,39 @@ void CBlender_Compile::SetMapping()
 	// PDA
 	r_Constant("pda_params", &binder_pda_params);
 
+	// Screen Space Shaders
+	r_Constant("ssfx_issvp", &ssfx_issvp);
+	r_Constant("ssfx_hud_hemi", &ssfx_hud_hemi);
+	r_Constant("ssfx_il_setup", &ssfx_il);
+	r_Constant("ssfx_il_setup2", &ssfx_il_setup1);
+	r_Constant("ssfx_ao_setup", &ssfx_ao);
+	r_Constant("ssfx_ao_setup2", &ssfx_ao_setup1);
+	r_Constant("ssfx_water", &ssfx_water);
+	r_Constant("ssfx_water_setup1", &ssfx_water_setup1);
+	r_Constant("ssfx_water_setup2", &ssfx_water_setup2);
+
+	r_Constant("ssfx_volumetric", &ssfx_volumetric);
+	r_Constant("ssfx_ssr_2", &ssfx_ssr_2);
+	r_Constant("ssfx_terrain_offset", &ssfx_terrain_offset);
+	r_Constant("ssfx_shadow_bias", &ssfx_shadow_bias);
+	r_Constant("ssfx_wind_anim", &ssfx_wind_anim);
+	r_Constant("sky_color", &binder_sky_color);
+	r_Constant("ssfx_wpn_dof_1", &ssfx_wpn_dof_1);
+	r_Constant("ssfx_wpn_dof_2", &ssfx_wpn_dof_2);
+	r_Constant("ssfx_blood_decals", &ssfx_blood_decals);
+	r_Constant("ssfx_hud_drops_1", &ssfx_hud_drops_1);
+	r_Constant("ssfx_hud_drops_2", &ssfx_hud_drops_2);
+	r_Constant("ssfx_lightsetup_1", &ssfx_lightsetup_1);
+	r_Constant("ssfx_is_underground", &ssfx_is_underground);
+	r_Constant("ssfx_wetsurfaces_1", &ssfx_wetsurfaces_1);
+	r_Constant("ssfx_wetsurfaces_2", &ssfx_wetsurfaces_2);
+	r_Constant("ssfx_gloss", &ssfx_gloss);
+	r_Constant("ssfx_florafixes_1", &ssfx_florafixes_1);
+	r_Constant("ssfx_florafixes_2", &ssfx_florafixes_2);
+	r_Constant("ssfx_wsetup_grass", &ssfx_wind_grass);
+	r_Constant("ssfx_wsetup_trees", &ssfx_wind_trees);
+	r_Constant("ssfx_lut", &ssfx_lut);
+
 	// Shader stuff
 	r_Constant("shader_param_1", &dev_param_1);
 	r_Constant("shader_param_2", &dev_param_2);
diff --git a/src/Layers/xrRender/Blender_tree.cpp b/src/Layers/xrRender/Blender_tree.cpp
index 7a8b831..00785fc 100644
--- a/src/Layers/xrRender/Blender_tree.cpp
+++ b/src/Layers/xrRender/Blender_tree.cpp
@@ -216,6 +216,13 @@ void CBlender_Tree::Compile(CBlender_Compile& C)
 	switch (C.iElement)
 	{
 	case SE_R2_NORMAL_HQ: // deffer
+
+#if defined(USE_DX11)
+		// Is a branch/bush. Use a different VS
+		if (oBlend.value && RImplementation.o.ssfx_branches)
+			tvs = "tree_branch";
+#endif
+
 		if (bUseATOC)
 		{
 			uber_deffer(C, true, tvs, "base_atoc", oBlend.value, 0, true);
@@ -230,6 +237,10 @@ void CBlender_Tree::Compile(CBlender_Compile& C)
 		uber_deffer(C, true, tvs, "base", oBlend.value, 0, true);
 		C.r_Stencil(TRUE, D3DCMP_ALWAYS, 0xff, 0x7f, D3DSTENCILOP_KEEP, D3DSTENCILOP_REPLACE, D3DSTENCILOP_KEEP);
 		C.r_StencilRef(0x01);
+
+		C.r_dx10Texture("s_waves", "fx\\wind_wave");
+		C.r_dx10Sampler("smp_linear2");
+
 		//C.PassSET_ZB		(true,false);
 		//	Need only for ATOC to emulate stencil test
 		if (bUseATOC)
@@ -252,6 +263,10 @@ void CBlender_Tree::Compile(CBlender_Compile& C)
 		uber_deffer(C, false, tvs, "base", oBlend.value, 0, true);
 		C.r_Stencil(TRUE, D3DCMP_ALWAYS, 0xff, 0x7f, D3DSTENCILOP_KEEP, D3DSTENCILOP_REPLACE, D3DSTENCILOP_KEEP);
 		C.r_StencilRef(0x01);
+
+		C.r_dx10Texture("s_waves", "fx\\wind_wave");
+		C.r_dx10Sampler("smp_linear2");
+
 		//	Need only for ATOC to emulate stencil test
 		if (bUseATOC)
 			C.RS.SetRS(D3DRS_ZFUNC, D3DCMP_EQUAL);
@@ -267,6 +282,10 @@ void CBlender_Tree::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_base", C.L_textures[0]);
 		C.r_dx10Sampler("smp_base");
 		C.r_dx10Sampler("smp_linear");
+
+		C.r_dx10Texture("s_waves", "fx\\wind_wave");
+		C.r_dx10Sampler("smp_linear2");
+
 		C.r_ColorWriteEnable(false, false, false, false);
 		C.r_End();
 		break;
diff --git a/src/Layers/xrRender/DetailManager.cpp b/src/Layers/xrRender/DetailManager.cpp
index 7d63982..613b5db 100644
--- a/src/Layers/xrRender/DetailManager.cpp
+++ b/src/Layers/xrRender/DetailManager.cpp
@@ -292,7 +292,7 @@ void CDetailManager::UpdateVisibleM()
 				continue;
 			}
 			u32 mask = 0xff;
-			u32 res = View.testSAABB(MS.vis.sphere.P, MS.vis.sphere.R, MS.vis.box.data(), mask);
+			u32 res = View.testSphere(MS.vis.sphere.P, MS.vis.sphere.R, mask);
 			if (fcvNone == res)
 			{
 				continue; // invisible-view frustum
@@ -319,7 +319,7 @@ void CDetailManager::UpdateVisibleM()
 				if (fcvPartial == res)
 				{
 					u32 _mask = mask;
-					u32 _res = View.testSAABB(S.vis.sphere.P, S.vis.sphere.R, S.vis.box.data(), _mask);
+					u32 _res = View.testSphere(S.vis.sphere.P, S.vis.sphere.R, _mask);
 					if (fcvNone == _res)
 					{
 						continue; // invisible-view frustum
@@ -370,7 +370,9 @@ void CDetailManager::UpdateVisibleM()
 							if (ssa > r_ssaCHEAP) vis_id = Item.vis_ID;
 
 							sp.r_items[vis_id].push_back(*siIT);
-
+							
+							Item.distance = dist_sq;
+							Item.position = S.vis.sphere.P;
 							//2							visible[vis_id][sp.id].push_back(&Item);
 						}
 					}
@@ -458,3 +460,27 @@ void __stdcall CDetailManager::MT_CALC()
 		}
 	MT.Leave();
 }
+
+void CDetailManager::details_clear()
+{
+	// Disable fade, next render will be scene
+	fade_distance = 99999;
+
+	if (ps_ssfx_grass_shadows.x <= 0)
+		return;
+
+	for (u32 x = 0; x < 3; x++)
+	{
+		vis_list& list = m_visibles[x];
+
+		for (u32 O = 0; O < objects.size(); O++)
+		{
+			CDetail& Object = *objects[O];
+			xr_vector<SlotItemVec*>& vis = list[O];
+			if (!vis.empty())
+			{
+				vis.clear_not_free();
+			}
+		}
+	}
+}
diff --git a/src/Layers/xrRender/DetailManager.h b/src/Layers/xrRender/DetailManager.h
index 5851f93..95da475 100644
--- a/src/Layers/xrRender/DetailManager.h
+++ b/src/Layers/xrRender/DetailManager.h
@@ -64,6 +64,12 @@ const float		dm_fade = float(2 * dm_size) - .5f;
 class ECORE_API CDetailManager
 {
 public:
+
+	float fade_distance = 99999;
+	Fvector light_position;
+
+	void details_clear();
+
 	struct SlotItem
 	{
 		// один кустик
@@ -73,6 +79,8 @@ public:
 		u32 vis_ID; // индекс в visibility списке он же тип [не качается, качается1, качается2]
 		float c_hemi;
 		float c_sun;
+		float distance;
+		Fvector position;
 #if RENDER==R_R1
 		Fvector c_rgb;
 #endif
diff --git a/src/Layers/xrRender/FTreeVisual.cpp b/src/Layers/xrRender/FTreeVisual.cpp
index 0489ef7..2afa75a 100644
--- a/src/Layers/xrRender/FTreeVisual.cpp
+++ b/src/Layers/xrRender/FTreeVisual.cpp
@@ -19,6 +19,9 @@ shared_str c_c_bias;
 shared_str c_c_scale;
 shared_str c_c_sun;
 
+shared_str c_c_BendersPos;
+shared_str c_c_BendersSetup;
+
 FTreeVisual::FTreeVisual(void)
 {
 }
@@ -91,6 +94,9 @@ void FTreeVisual::Load(const char* N, IReader* data, u32 dwFlags)
 	c_c_bias = "c_bias";
 	c_c_scale = "c_scale";
 	c_c_sun = "c_sun";
+
+	c_c_BendersPos = "benders_pos";
+	c_c_BendersSetup = "benders_setup";
 }
 
 struct FTreeVisual_setup
@@ -160,6 +166,47 @@ void FTreeVisual::Render(float LOD)
 	                       s * c_bias.rgb.z + desc.ambient.z, s * c_bias.hemi); // bias
 #endif
 	RCache.tree.set_c_sun(s * c_scale.sun, s * c_bias.sun, 0, 0); // sun
+
+#if RENDER==R_R4 || RENDER==R_R3
+
+	if (ps_ssfx_grass_interactive.y > 0)
+	{
+		// Inter grass Settings
+		RCache.set_c(c_c_BendersSetup, ps_ssfx_int_grass_params_1);
+
+		// Grass benders data ( Player + Characters )
+		IGame_Persistent::grass_data& GData = g_pGamePersistent->grass_shader_data;
+		Fvector4 player_pos = { 0, 0, 0, 0 };
+		int BendersQty = _min(16, ps_ssfx_grass_interactive.y + 1);
+
+		// Add Player?
+		if (ps_ssfx_grass_interactive.x > 0)
+		{
+			player_pos.set(Device.vCameraPosition.x, Device.vCameraPosition.y, Device.vCameraPosition.z, -1);
+		}
+
+		Fvector4* c_grass;
+		{
+			void* GrassData;
+			RCache.get_ConstantDirect(c_c_BendersPos, BendersQty * sizeof(Fvector4) * 2, &GrassData, 0, 0);
+
+			c_grass = (Fvector4*)GrassData;
+		}
+		VERIFY(c_grass);
+
+		if (c_grass)
+		{
+			c_grass[0].set(player_pos);
+			c_grass[16].set(0.0f, -99.0f, 0.0f, 1.0f);
+
+			for (int Bend = 1; Bend < BendersQty; Bend++)
+			{
+				c_grass[Bend].set(GData.pos[Bend].x, GData.pos[Bend].y, GData.pos[Bend].z, GData.radius_curr[Bend]);
+				c_grass[Bend + 16].set(GData.dir[Bend].x, GData.dir[Bend].y, GData.dir[Bend].z, GData.str[Bend]);
+			}
+		}
+	}
+#endif
 }
 
 #define PCOPY(a)	a = pFrom->a
diff --git a/src/Layers/xrRender/ResourceManager.cpp b/src/Layers/xrRender/ResourceManager.cpp
index 681f58b..aef5c55 100644
--- a/src/Layers/xrRender/ResourceManager.cpp
+++ b/src/Layers/xrRender/ResourceManager.cpp
@@ -176,6 +176,11 @@ Shader* CResourceManager::_cpp_Create(IBlender* B, LPCSTR s_shader, LPCSTR s_tex
 	C.BT = B;
 	C.bEditor = FALSE;
 	C.bDetail = FALSE;
+
+#if defined(USE_DX11)
+	C.HudElement = false;
+#endif
+
 #ifdef _EDITOR
 	if (!C.BT)			{ ELog.Msg(mtError,"Can't find shader '%s'",s_shader); return 0; }
 	C.bEditor			= TRUE;
@@ -186,6 +191,13 @@ Shader* CResourceManager::_cpp_Create(IBlender* B, LPCSTR s_shader, LPCSTR s_tex
 	_ParseList(C.L_constants, s_constants);
 	_ParseList(C.L_matrices, s_matrices);
 
+#if defined(USE_DX11)
+	if (::Render->hud_loading && RImplementation.o.ssfx_hud_raindrops)
+	{
+		C.HudElement = true;
+	}
+#endif
+
 	// Compile element	(LOD0 - HQ)
 	{
 		C.iElement = 0;
@@ -242,6 +254,13 @@ Shader* CResourceManager::_cpp_Create(IBlender* B, LPCSTR s_shader, LPCSTR s_tex
 		S.E[5] = _CreateElement(E);
 	}
 
+	// Hacky way to remove from the HUD mask transparent stuff. ( Let's try something better later... )
+	if (::Render->hud_loading)
+	{
+		if (strstr(s_shader, "lens"))
+			S.E[0]->passes[0]->ps->hud_disabled = TRUE;
+	}
+
 	// Search equal in shaders array
 	for (u32 it = 0; it < v_shaders.size(); it++)
 		if (S.equal(v_shaders[it])) return v_shaders[it];
diff --git a/src/Layers/xrRender/Shader.cpp b/src/Layers/xrRender/Shader.cpp
index fff3202..e42bd49 100644
--- a/src/Layers/xrRender/Shader.cpp
+++ b/src/Layers/xrRender/Shader.cpp
@@ -104,6 +104,10 @@ ShaderElement::ShaderElement()
 	flags.bDistort = FALSE;
 	flags.bWmark = FALSE;
 	flags.bLandscape = FALSE;
+	
+	// SSS Custom rendering
+	flags.isLandscape = FALSE;
+	flags.isWater = FALSE;
 }
 
 BOOL ShaderElement::equal(ShaderElement& S)
diff --git a/src/Layers/xrRender/Shader.h b/src/Layers/xrRender/Shader.h
index 015d76a..ac98427 100644
--- a/src/Layers/xrRender/Shader.h
+++ b/src/Layers/xrRender/Shader.h
@@ -127,6 +127,8 @@ public:
 		u32 bDistort : 1;
 		u32 bWmark : 1;
 		u32 bLandscape : 1;
+		u32 isLandscape : 1;
+		u32 isWater : 1;
 	};
 
 public:
diff --git a/src/Layers/xrRender/SkeletonCustom.h b/src/Layers/xrRender/SkeletonCustom.h
index ebe9cb3..f61a346 100644
--- a/src/Layers/xrRender/SkeletonCustom.h
+++ b/src/Layers/xrRender/SkeletonCustom.h
@@ -123,6 +123,7 @@ public:
 protected:
 	SkeletonWMVec wallmarks;
 	u32 wm_frame;
+	u32 CurrentFrame;
 
 	xr_vector<dxRender_Visual*> children_invisible;
 
diff --git a/src/Layers/xrRender/SkeletonX.cpp b/src/Layers/xrRender/SkeletonX.cpp
index 505a441..31d1315 100644
--- a/src/Layers/xrRender/SkeletonX.cpp
+++ b/src/Layers/xrRender/SkeletonX.cpp
@@ -21,6 +21,7 @@
 #include "../../xrCPU_Pipe/xrCPU_Pipe.h"
 
 shared_str s_bones_array_const;
+shared_str s_bones_array_prev_const;
 
 //////////////////////////////////////////////////////////////////////
 // Body Part
@@ -57,6 +58,33 @@ void CSkeletonX::_Copy(CSkeletonX* B)
 //////////////////////////////////////////////////////////////////////
 void CSkeletonX::_Render(ref_geom& hGeom, u32 vCount, u32 iOffset, u32 pCount)
 {
+	bool CalcVelocity = false;
+
+#ifdef USE_DX11
+
+	CalcVelocity = RImplementation.Target->RVelocity;
+
+	if (CalcVelocity)
+	{
+		// Previous WVP
+		RCache.set_c("m_WVP_prev", RImplementation.Target->Matrix_HUD_previous);
+
+		if (RenderMode > 1 && Device.dwFrame > Parent->CurrentFrame)
+		{
+			Parent->CurrentFrame = Device.dwFrame;
+
+			// Save bone matrix to use next frame
+			for (u16 b = 0; b < Parent->LL_BoneCount(); b++)
+			{
+				CBoneInstance& Bone = Parent->LL_GetBoneInstance(b);
+				Bone.mRenderTransform_prev.set(Bone.mRenderTransform_temp);
+				Bone.mRenderTransform_temp.set(Bone.mRenderTransform);
+			}
+		}
+	}
+
+#endif
+
 	RCache.stat.r.s_dynamic.add(vCount);
 	switch (RenderMode)
 	{
@@ -69,6 +97,11 @@ void CSkeletonX::_Render(ref_geom& hGeom, u32 vCount, u32 iOffset, u32 pCount)
 			Fmatrix W;
 			W.mul_43(RCache.xforms.m_w, Parent->LL_GetTransform_R(u16(RMS_boneid)));
 			RCache.set_xform_world(W);
+
+			// Add the bone transform
+			if (CalcVelocity)
+				RCache.set_c("m_bone", Parent->LL_GetTransform_R(u16(RMS_boneid)));
+
 			RCache.set_Geometry(hGeom);
 			RCache.Render(D3DPT_TRIANGLELIST, 0, 0, vCount, iOffset, pCount);
 			RCache.stat.r.s_dynamic_inst.add(vCount);
@@ -79,8 +112,10 @@ void CSkeletonX::_Render(ref_geom& hGeom, u32 vCount, u32 iOffset, u32 pCount)
 	case RM_SKINNING_3B:
 	case RM_SKINNING_4B:
 		{
-			// transfer matrices
+			// Transfer matrices ( current and previous )
 			ref_constant array = RCache.get_c(s_bones_array_const);
+			ref_constant array_prev = RCache.get_c(s_bones_array_prev_const);
+
 			u32 count = RMS_bonecount;
 			for (u32 mid = 0; mid < count; mid++)
 			{
@@ -89,6 +124,15 @@ void CSkeletonX::_Render(ref_geom& hGeom, u32 vCount, u32 iOffset, u32 pCount)
 				RCache.set_ca(&*array, id + 0, M._11, M._21, M._31, M._41);
 				RCache.set_ca(&*array, id + 1, M._12, M._22, M._32, M._42);
 				RCache.set_ca(&*array, id + 2, M._13, M._23, M._33, M._43);
+
+				if (CalcVelocity)
+				{
+					// Previus transform
+					Fmatrix& Mprev = Parent->LL_GetBoneInstance(u16(mid)).mRenderTransform_prev;
+					RCache.set_ca(&*array_prev, id + 0, Mprev._11, Mprev._21, Mprev._31, Mprev._41);
+					RCache.set_ca(&*array_prev, id + 1, Mprev._12, Mprev._22, Mprev._32, Mprev._42);
+					RCache.set_ca(&*array_prev, id + 2, Mprev._13, Mprev._23, Mprev._33, Mprev._43);
+				}
 			}
 
 			// render
@@ -170,6 +214,7 @@ void CSkeletonX::_Render_soft(ref_geom& hGeom, u32 vCount, u32 iOffset, u32 pCou
 void CSkeletonX::_Load(const char* N, IReader* data, u32& dwVertCount)
 {
 	s_bones_array_const = "sbones_array";
+	s_bones_array_prev_const = "sbones_array_prev";
 	xr_vector<u16> bids;
 
 	// Load vertices
diff --git a/src/Layers/xrRender/blenders/Blender_Recorder.h b/src/Layers/xrRender/blenders/Blender_Recorder.h
index 6e2efdf..57f0f51 100644
--- a/src/Layers/xrRender/blenders/Blender_Recorder.h
+++ b/src/Layers/xrRender/blenders/Blender_Recorder.h
@@ -26,6 +26,7 @@ public:
 	BOOL bDetail_Bump;
 	BOOL bUseSteepParallax;
 	int iElement;
+	bool HudElement = false;
 
 public:
 	CSimulator RS;
diff --git a/src/Layers/xrRender/dxRainRender.cpp b/src/Layers/xrRender/dxRainRender.cpp
index e67cfb2..dc6fbe6 100644
--- a/src/Layers/xrRender/dxRainRender.cpp
+++ b/src/Layers/xrRender/dxRainRender.cpp
@@ -5,14 +5,14 @@
 
 //	Warning: duplicated in rain.cpp
 static const int max_desired_items = 2500;
-static const float source_radius = 12.5f;
-static const float source_offset = 40.f;
-static const float max_distance = source_offset * 1.25f;
+static const float source_radius = 15;//12.5f;
+static const float source_offset = 20.f; // 40
+static const float max_distance = source_offset * 1.5f; //1.25f;
 static const float sink_offset = -(max_distance - source_offset);
 static const float drop_length = 5.f;
 static const float drop_width = 0.30f;
 static const float drop_angle = 3.0f;
-static const float drop_max_angle = deg2rad(10.f);
+static const float drop_max_angle = deg2rad(35.f); //10
 static const float drop_max_wind_vel = 20.0f;
 static const float drop_speed_min = 40.f;
 static const float drop_speed_max = 80.f;
@@ -21,8 +21,12 @@ const int max_particles = 1000;
 const int particles_cache = 400;
 const float particles_time = .3f;
 
+int current_items;
+
 dxRainRender::dxRainRender()
 {
+	current_items = 0;
+
 	IReader* F = FS.r_open("$game_meshes$", "dm\\rain.dm");
 	VERIFY3(F, "Can't open file.", "dm\\rain.dm");
 
@@ -33,6 +37,11 @@ dxRainRender::dxRainRender()
 	hGeom_Rain.create(FVF::F_LIT, RCache.Vertex.Buffer(), RCache.QuadIB);
 	hGeom_Drops.create(D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1, RCache.Vertex.Buffer(), RCache.Index.Buffer());
 
+#if defined(USE_DX11)
+	if (RImplementation.o.ssfx_rain)
+		SH_Splash.create("effects\\rain_splash", "fx\\fx_rain");
+#endif
+
 	FS.r_close(F);
 }
 
@@ -53,21 +62,43 @@ void dxRainRender::Render(CEffect_Rain& owner)
 	float factor = g_pGamePersistent->Environment().CurrentEnv->rain_density;
 	if (factor < EPS_L) return;
 
-	u32 desired_items = iFloor(0.5f * (1.f + factor) * float(max_desired_items));
+	float _drop_len = drop_length;
+	float _drop_width = drop_width;
+	float _drop_speed = 1.0f;
+	ref_shader& _splash_SH = DM_Drop->shader;
+	static shared_str s_shader_setup = "ssfx_rain_setup";
+
+	// SSS Rain shader is available
+#if defined(USE_DX11)
+	if (RImplementation.o.ssfx_rain)
+	{
+		_drop_len = ps_ssfx_rain_1.x;
+		_drop_width = ps_ssfx_rain_1.y;
+		_drop_speed = ps_ssfx_rain_1.z;
+		_splash_SH = SH_Splash;
+	}
+#endif
+
+	u32 desired_items = iFloor(0.01f * (1.f + factor * 99.0f) * float(max_desired_items));
+
+	// Get to the desired items
+	if (current_items < desired_items)
+		current_items += desired_items - current_items;
+
 	// visual
 	float factor_visual = factor / 2.f + .5f;
 	Fvector3 f_rain_color = g_pGamePersistent->Environment().CurrentEnv->rain_color;
 	u32 u_rain_color = color_rgba_f(f_rain_color.x, f_rain_color.y, f_rain_color.z, factor_visual);
 
 	// born _new_ if needed
-	float b_radius_wrap_sqr = _sqr((source_radius + .5f));
-	if (owner.items.size() < desired_items)
+	float b_radius_wrap_sqr = _sqr((source_radius * 1.5f));
+	if (owner.items.size() < current_items)
 	{
 		// owner.items.reserve		(desired_items);
-		while (owner.items.size() < desired_items)
+		while (owner.items.size() < current_items)
 		{
 			CEffect_Rain::Item one;
-			owner.Born(one, source_radius);
+			owner.Born(one, source_radius, _drop_speed);
 			owner.items.push_back(one);
 		}
 	}
@@ -84,13 +115,21 @@ void dxRainRender::Render(CEffect_Rain& owner)
 	FVF::LIT* verts = (FVF::LIT *)RCache.Vertex.Lock(desired_items * 4, hGeom_Rain->vb_stride, vOffset);
 	FVF::LIT* start = verts;
 	const Fvector& vEye = Device.vCameraPosition;
-	for (u32 I = 0; I < owner.items.size(); I++)
+	for (u32 I = 0; I < current_items; I++)
 	{
 		// physics and time control
 		CEffect_Rain::Item& one = owner.items[I];
 
-		if (one.dwTime_Hit < Device.dwTimeGlobal) owner.Hit(one.Phit);
-		if (one.dwTime_Life < Device.dwTimeGlobal) owner.Born(one, source_radius);
+		if (one.dwTime_Hit < Device.dwTimeGlobal) 
+		{
+			owner.Hit(one.Phit);
+			if (current_items > desired_items) current_items--; // Hit something
+		}
+		if (one.dwTime_Life < Device.dwTimeGlobal)
+		{
+			owner.Born(one, source_radius, _drop_speed);
+			if (current_items > desired_items) current_items--; // Out of life ( invalidated, never hit something, etc. )
+		}
 
 		// последняя дельта ??
 		//.		float xdt		= float(one.dwTime_Hit-Device.dwTimeGlobal)/1000.f;
@@ -154,7 +193,7 @@ void dxRainRender::Render(CEffect_Rain& owner)
 		// Build line
 		Fvector& pos_head = one.P;
 		Fvector pos_trail;
-		pos_trail.mad(pos_head, one.D, -drop_length * factor_visual);
+		pos_trail.mad(pos_head, one.D, -_drop_len * factor_visual);
 
 		// Culling
 		Fvector sC, lineD;
@@ -176,7 +215,7 @@ void dxRainRender::Render(CEffect_Rain& owner)
 		camDir.sub(sC, vEye);
 		camDir.normalize();
 		lineTop.crossproduct(camDir, lineD);
-		float w = drop_width;
+		float w = _drop_width;
 		u32 s = one.uv_set;
 		P.mad(pos_trail, lineTop, -w);
 		verts->set(P, u_rain_color, UV[s][0].x, UV[s][0].y);
@@ -205,6 +244,7 @@ void dxRainRender::Render(CEffect_Rain& owner)
 		RCache.Render(D3DPT_TRIANGLELIST, vOffset, 0, vCount, 0, vCount / 2);
 		//HW.pDevice->SetRenderState	(D3DRS_CULLMODE,D3DCULL_CCW);
 		RCache.set_CullMode(CULL_CCW);
+		RCache.set_c(s_shader_setup, ps_ssfx_rain_2); // Alpha, Brigthness, Refraction, Reflection
 	}
 
 	// Particles
@@ -214,7 +254,8 @@ void dxRainRender::Render(CEffect_Rain& owner)
 	{
 		float dt = Device.fTimeDelta;
 		_IndexStream& _IS = RCache.Index;
-		RCache.set_Shader(DM_Drop->shader);
+		RCache.set_Shader(_splash_SH);
+		RCache.set_c(s_shader_setup, ps_ssfx_rain_3); // Alpha, Refraction
 
 		Fmatrix mXform, mScale;
 		int pcount = 0;
diff --git a/src/Layers/xrRender/dxRainRender.h b/src/Layers/xrRender/dxRainRender.h
index 80dcbc9..4b76746 100644
--- a/src/Layers/xrRender/dxRainRender.h
+++ b/src/Layers/xrRender/dxRainRender.h
@@ -23,6 +23,7 @@ private:
 	// Visualization	(drops)
 	IRender_DetailModel* DM_Drop;
 	ref_geom hGeom_Drops;
+	ref_shader SH_Splash;
 };
 
 #endif	//	RainRender_included
diff --git a/src/Layers/xrRender/dxWallMarkArray.cpp b/src/Layers/xrRender/dxWallMarkArray.cpp
index 384d8d3..847c526 100644
--- a/src/Layers/xrRender/dxWallMarkArray.cpp
+++ b/src/Layers/xrRender/dxWallMarkArray.cpp
@@ -17,7 +17,24 @@ dxWallMarkArray::~dxWallMarkArray()
 void dxWallMarkArray::AppendMark(LPCSTR s_textures)
 {
 	ref_shader s;
+
+#if defined(USE_DX11)
+
+	LPCSTR sh_name = "effects\\wallmark";
+
+	if (RImplementation.o.ssfx_blood)
+	{
+		// Use the blood shader for any texture with the name wm_blood_*
+		if (strstr(s_textures, "wm_blood_"))
+			sh_name = "effects\\wallmark_blood";
+	}
+
+	s.create(sh_name, s_textures);
+
+#else
 	s.create("effects\\wallmark", s_textures);
+#endif
+
 	m_CollideMarks.push_back(s);
 }
 
diff --git a/src/Layers/xrRender/light.cpp b/src/Layers/xrRender/light.cpp
index 1b28f32..2725922 100644
--- a/src/Layers/xrRender/light.cpp
+++ b/src/Layers/xrRender/light.cpp
@@ -366,7 +366,9 @@ void light::export_(light_Package& package)
 #endif	//	(RENDER==R_R3) || (RENDER==R_R4)
 
 					//	Igor: add volumetric support
-					L->set_volumetric(flags.bVolumetric);
+					if (ps_ssfx_volumetric.x <= 0)
+						L->set_volumetric(flags.bVolumetric);
+
 					L->set_volumetric_quality(m_volumetric_quality);
 					L->set_volumetric_intensity(m_volumetric_intensity);
 					L->set_volumetric_distance(m_volumetric_distance);
@@ -376,6 +378,7 @@ void light::export_(light_Package& package)
 			}
 			break;
 		case IRender_Light::SPOT:
+			this->set_volumetric_intensity(m_volumetric_intensity);
 			package.v_shadowed.push_back(this);
 			break;
 		}
diff --git a/src/Layers/xrRender/light.h b/src/Layers/xrRender/light.h
index 8146a37..ec81dc8 100644
--- a/src/Layers/xrRender/light.h
+++ b/src/Layers/xrRender/light.h
@@ -9,6 +9,8 @@
 #	include "light_GI.h"
 #endif //(RENDER==R_R2) || (RENDER==R_R3) || (RENDER==R_R4)
 
+extern Fvector4 ps_ssfx_volumetric;
+
 class light : public IRender_Light, public ISpatial
 {
 public:
@@ -70,6 +72,7 @@ public:
 		bool		visible;		// visible/invisible
 		bool		pending;		// test is still pending
 		u16			smap_ID;
+		float		distance;
 	}				vis;
 
 	union			_xform	{
@@ -109,12 +112,15 @@ public:
 
 	virtual void set_volumetric(bool b)
 	{
+		if (ps_ssfx_volumetric.x > 0)
+			b = true;
+
 		flags.bVolumetric = b;
 	}
 
 	virtual void set_volumetric_quality(float fValue) { m_volumetric_quality = fValue; }
-	virtual void set_volumetric_intensity(float fValue) { m_volumetric_intensity = fValue; }
-	virtual void set_volumetric_distance(float fValue) { m_volumetric_distance = fValue; }
+	virtual void set_volumetric_intensity(float fValue) { m_volumetric_intensity = ps_ssfx_volumetric.y; }
+	virtual void set_volumetric_distance(float fValue) { m_volumetric_distance = 1.0f; }
 
 	virtual void set_position(const Fvector& P);
 	virtual void set_rotation(const Fvector& D, const Fvector& R);
diff --git a/src/Layers/xrRender/r__dsgraph_build.cpp b/src/Layers/xrRender/r__dsgraph_build.cpp
index 274542b..c06fce5 100644
--- a/src/Layers/xrRender/r__dsgraph_build.cpp
+++ b/src/Layers/xrRender/r__dsgraph_build.cpp
@@ -105,6 +105,17 @@ void R_dsgraph_structure::r_dsgraph_insert_dynamic(dxRender_Visual* pVisual, Fve
 			N->val.pVisual = pVisual;
 			N->val.Matrix = *RI.val_pTransform;
 			N->val.se = sh;
+
+			if (!sh->passes[0]->ps->hud_disabled)
+			{
+				HUDMask_Node* N2 = HUDMask.insertInAnyWay(distSQ);
+				N2->val.ssa = SSA;
+				N2->val.pObject = RI.val_pObject;
+				N2->val.pVisual = pVisual;
+				N2->val.Matrix = *RI.val_pTransform;
+				N2->val.se = sh;
+			}
+
 #if RENDER!=R_R1
 			if (sh->flags.bEmissive)
 			{
@@ -302,6 +313,18 @@ void R_dsgraph_structure::r_dsgraph_insert_static(dxRender_Visual* pVisual)
 	if (0 == sh) return;
 	if (!pmask[sh->flags.iPriority / 2]) return;
 
+	// Water rendering
+	if (sh->flags.isWater)
+	{
+		mapWater_Node* N = mapWater.insertInAnyWay(distSQ);
+		N->val.ssa = SSA;
+		N->val.pObject = NULL;
+		N->val.pVisual = pVisual;
+		N->val.Matrix = Fidentity;
+		N->val.se = sh;
+		return;
+	}
+
 	// strict-sorting selection
 	if (sh->flags.bStrictB2F)
 	{
@@ -592,7 +615,7 @@ IC bool IsValuableToRender(dxRender_Visual* pVisual, bool isStatic, bool sm, Fma
 
 		if (sm && !!psDeviceFlags2.test(rsOptShadowGeom)) // Highest cut off for shadow map
 		{
-			if (sphere_volume < 50000.f && adjusted_distane > 160)
+			if (sphere_volume < 50000.f && adjusted_distane > ps_ssfx_shadow_cascades.z)
 				// don't need geometry behind the farest sun shadow cascade
 				return false;
 
@@ -606,10 +629,16 @@ IC bool IsValuableToRender(dxRender_Visual* pVisual, bool isStatic, bool sm, Fma
 				return false;
 			else if ((sphere_volume < o_optimize_static_l5_size.z) && (adjusted_distane > o_optimize_static_l5_dist.z))
 				return false;
+
+			return true;
 		}
 
 		if (isStatic)
 		{
+
+			if (pVisual->Type == MT_LOD || pVisual->Type == MT_TREE_PM || pVisual->Type == MT_TREE_ST)
+				return true;
+
 			if (opt_static == 2)
 			{
 				if ((sphere_volume < o_optimize_static_l1_size.y) && (adjusted_distane > o_optimize_static_l1_dist.y))
diff --git a/src/Layers/xrRender/r__dsgraph_render.cpp b/src/Layers/xrRender/r__dsgraph_render.cpp
index 9ef142d..e4a7929 100644
--- a/src/Layers/xrRender/r__dsgraph_render.cpp
+++ b/src/Layers/xrRender/r__dsgraph_render.cpp
@@ -83,6 +83,82 @@ void __fastcall sorted_L1(mapSorted_Node* N)
 	V->Render(calcLOD(N->key, V->vis.sphere.R));
 }
 
+void __fastcall water_node_ssr(mapSorted_Node* N)
+{
+#ifdef USE_DX11
+	VERIFY(N);
+	dxRender_Visual* V = N->val.pVisual;
+	VERIFY(V);
+
+	RCache.set_Shader(RImplementation.Target->s_ssfx_water_ssr);
+
+	RCache.set_xform_world(N->val.Matrix);
+	RImplementation.apply_object(N->val.pObject);
+	RImplementation.apply_lmaterial();
+
+	RCache.set_c("cam_pos", RImplementation.Target->Position_previous.x, RImplementation.Target->Position_previous.y, RImplementation.Target->Position_previous.z, 0.0f);
+
+	// Previous matrix data
+	RCache.set_c("m_previous", N->val.PrevMatrix);
+	N->val.PrevMatrix.set(RCache.xforms.m_wvp);
+
+	V->Render(calcLOD(N->key, V->vis.sphere.R));
+#endif
+}
+
+void __fastcall water_node(mapSorted_Node* N)
+{
+	VERIFY(N);
+	dxRender_Visual* V = N->val.pVisual;
+	VERIFY(V);
+
+#ifdef USE_DX11
+	if (RImplementation.o.ssfx_water)
+	{
+		RCache.set_Shader(RImplementation.Target->s_ssfx_water);
+	}
+#endif
+
+	RCache.set_xform_world(N->val.Matrix);
+	RImplementation.apply_object(N->val.pObject);
+	RImplementation.apply_lmaterial();
+
+	// Wind settings
+	float WindDir = g_pGamePersistent->Environment().CurrentEnv->wind_direction;
+	float WindVel = g_pGamePersistent->Environment().CurrentEnv->wind_velocity;
+	RCache.set_c("wind_setup", WindDir, WindVel, 0, 0);
+
+	V->Render(calcLOD(N->key, V->vis.sphere.R));
+}
+
+void __fastcall hud_node(mapSorted_Node* N)
+{
+	VERIFY(N);
+	dxRender_Visual* V = N->val.pVisual;
+	VERIFY(V && V->shader._get());
+	RCache.set_xform_world(N->val.Matrix);
+
+#ifdef USE_DX11
+
+	if (N->val.se->passes[0]->ps->hud_disabled)
+		return;
+
+	int skinning = N->val.se->passes[0]->vs->skinning;
+	RCache.set_Shader(RImplementation.Target->s_ssfx_hud[skinning]);
+
+	RImplementation.Target->Matrix_HUD_previous.set(N->val.PrevMatrix);
+	N->val.PrevMatrix.set(RCache.xforms.m_wvp);
+
+	RImplementation.Target->RVelocity = true;
+
+#endif
+
+	V->Render(calcLOD(N->key, V->vis.sphere.R));
+
+#ifdef USE_DX11
+	RImplementation.Target->RVelocity = false;
+#endif
+
 IC bool cmp_vs_nrm(mapNormalVS::TNode* N1, mapNormalVS::TNode* N2)
 {
 	return (N1->val.ssa > N2->val.ssa);
@@ -499,7 +575,7 @@ void R_dsgraph_structure::r_dsgraph_render_graph(u32 _priority, bool _clear)
 
 //////////////////////////////////////////////////////////////////////////
 // HUD render
-void R_dsgraph_structure::r_dsgraph_render_hud()
+void R_dsgraph_structure::r_dsgraph_render_hud(bool NoPS)
 {
 	//PIX_EVENT(r_dsgraph_render_hud);
 
@@ -518,8 +594,16 @@ void R_dsgraph_structure::r_dsgraph_render_hud()
 
 	// Rendering
 	rmNear();
-	mapHUD.traverseLR(sorted_L1);
-	mapHUD.clear();
+	if (!NoPS)
+	{
+		mapHUD.traverseLR(sorted_L1);
+		mapHUD.clear();
+	}
+	else
+	{
+		HUDMask.traverseLR(hud_node);
+		HUDMask.clear();
+	}
 
 #if	RENDER==R_R1
 	if (g_hud && g_hud->RenderActiveItemUIQuery())
@@ -656,6 +740,17 @@ void R_dsgraph_structure::r_dsgraph_render_emissive()
 #endif
 }
 
+void R_dsgraph_structure::r_dsgraph_render_water_ssr()
+{
+	mapWater.traverseLR(water_node_ssr);
+}
+
+void R_dsgraph_structure::r_dsgraph_render_water()
+{
+	mapWater.traverseLR(water_node);
+	mapWater.clear();
+}
+
 //////////////////////////////////////////////////////////////////////////
 // strict-sorted render
 void R_dsgraph_structure::r_dsgraph_render_wmarks()
diff --git a/src/Layers/xrRender/r__dsgraph_structure.h b/src/Layers/xrRender/r__dsgraph_structure.h
index 412db6c..13492a2 100644
--- a/src/Layers/xrRender/r__dsgraph_structure.h
+++ b/src/Layers/xrRender/r__dsgraph_structure.h
@@ -44,6 +44,8 @@ public:
 	R_dsgraph::mapSorted_T mapDistort;
 	R_dsgraph::mapHUD_T mapHUDSorted;
 	R_dsgraph::mapLandscape_T mapLandscape;
+	R_dsgraph::HUDMask_T HUDMask;
+	R_dsgraph::mapWater_T mapWater;
 
 #if RENDER!=R_R1
 	R_dsgraph::mapSorted_T										mapWmark;			// sorted
@@ -170,6 +172,8 @@ public:
 		mapDistort.destroy();
 		mapHUDSorted.destroy();
 		mapLandscape.destroy();
+		HUDMask.destroy();
+		mapWater.destroy();
 
 #if RENDER!=R_R1
 		mapWmark.destroy		();
@@ -189,7 +193,7 @@ public:
 	void r_dsgraph_insert_static(dxRender_Visual* pVisual);
 
 	void r_dsgraph_render_graph(u32 _priority, bool _clear = true);
-	void r_dsgraph_render_hud();
+	void r_dsgraph_render_hud(bool NoPS = false);
 	void r_dsgraph_render_hud_ui();
 	void r_dsgraph_render_lods(bool _setup_zb, bool _clear);
 	void r_dsgraph_render_sorted();
@@ -203,6 +207,8 @@ public:
 	void r_dsgraph_render_R1_box(IRender_Sector* _sector, Fbox& _bb, int _element);
 
 	void r_dsgraph_render_landscape(u32 pass, bool _clear);
+	void r_dsgraph_render_water_ssr();
+	void r_dsgraph_render_water();
 
 
 public:
diff --git a/src/Layers/xrRender/r__dsgraph_types.h b/src/Layers/xrRender/r__dsgraph_types.h
index ba7d098..61e95a4 100644
--- a/src/Layers/xrRender/r__dsgraph_types.h
+++ b/src/Layers/xrRender/r__dsgraph_types.h
@@ -80,6 +80,7 @@ namespace R_dsgraph
 		IRenderable* pObject;
 		dxRender_Visual* pVisual;
 		Fmatrix Matrix; // matrix (copy)
+		Fmatrix PrevMatrix;
 	};
 
 	struct _MatrixItemS : public _MatrixItem
@@ -218,9 +219,16 @@ namespace R_dsgraph
 	typedef FixedMAP<float, _MatrixItemS, render_allocator> mapHUD_T;
 	typedef mapHUD_T::TNode mapHUD_Node;
 
+	typedef FixedMAP<float, _MatrixItemS, render_allocator> HUDMask_T;
+	typedef HUDMask_T::TNode HUDMask_Node;
+
 	typedef FixedMAP<float, _LodItem, render_allocator> mapLOD_T;
 	typedef mapLOD_T::TNode mapLOD_Node;
 
 	typedef FixedMAP<float, _MatrixItemS, render_allocator> mapLandscape_T;
 	typedef mapLandscape_T::TNode mapLandscape_Node;
+
+	typedef FixedMAP<float, _MatrixItemS, render_allocator> mapWater_T;
+	typedef mapWater_T::TNode mapWater_Node;
+
 };
diff --git a/src/Layers/xrRender/rendertarget_phase_blur.cpp b/src/Layers/xrRender/rendertarget_phase_blur.cpp
index ae26f3a..eb036b1 100644
--- a/src/Layers/xrRender/rendertarget_phase_blur.cpp
+++ b/src/Layers/xrRender/rendertarget_phase_blur.cpp
@@ -1,5 +1,7 @@
 #include "stdafx.h"
 
+
+
 void CRenderTarget::phase_blur()
 {
 	//Get common data
@@ -7,11 +9,11 @@ void CRenderTarget::phase_blur()
 	float d_Z = EPS_S;
 	float d_W = 1.0f;
 	u32 C = color_rgba(0, 0, 0, 255);
-	
+
 	//Full resolution
 	float w = float(Device.dwWidth);
-	float h = float(Device.dwHeight);	
-	
+	float h = float(Device.dwHeight);
+
 	Fvector2 p0, p1;
 #if defined(USE_DX10) || defined(USE_DX11)	
 	p0.set(0.0f, 0.0f);
@@ -20,10 +22,10 @@ void CRenderTarget::phase_blur()
 	p0.set(0.5f / w, 0.5f / h);
 	p1.set((w + 0.5f) / w, (h + 0.5f) / h);
 #endif
-	
-///////////////////////////////////////////////////////////////////////////////////
-////Horizontal blur
-///////////////////////////////////////////////////////////////////////////////////
+
+	///////////////////////////////////////////////////////////////////////////////////
+	////Horizontal blur
+	///////////////////////////////////////////////////////////////////////////////////
 	w = float(Device.dwWidth) * 0.5f;
 	h = float(Device.dwHeight) * 0.5f;
 
@@ -41,12 +43,12 @@ void CRenderTarget::phase_blur()
 
 	// Draw COLOR
 	RCache.set_Element(s_blur->E[0]);
-	RCache.set_c("blur_params", 1.0, 0.0, w, h);	
+	RCache.set_c("blur_params", 1.0, 0.0, w, h);
 	RCache.set_Geometry(g_combine);
 	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
-///////////////////////////////////////////////////////////////////////////////////
-////Final blur
-///////////////////////////////////////////////////////////////////////////////////
+	///////////////////////////////////////////////////////////////////////////////////
+	////Final blur
+	///////////////////////////////////////////////////////////////////////////////////
 	u_setrt(rt_blur_2, 0, 0, HW.pBaseZB);
 	RCache.set_CullMode(CULL_NONE);
 	RCache.set_Stencil(FALSE);
@@ -61,12 +63,12 @@ void CRenderTarget::phase_blur()
 
 	// Draw COLOR
 	RCache.set_Element(s_blur->E[1]);
-	RCache.set_c("blur_params", 0.0, 1.0, w, h);	
+	RCache.set_c("blur_params", 0.0, 1.0, w, h);
 	RCache.set_Geometry(g_combine);
 	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
-///////////////////////////////////////////////////////////////////////////////////
-////Horizontal blur / Half res
-///////////////////////////////////////////////////////////////////////////////////
+	///////////////////////////////////////////////////////////////////////////////////
+	////Horizontal blur / Half res
+	///////////////////////////////////////////////////////////////////////////////////
 	w = float(Device.dwWidth) * 0.25f;
 	h = float(Device.dwHeight) * 0.25f;
 
@@ -84,12 +86,12 @@ void CRenderTarget::phase_blur()
 
 	// Draw COLOR
 	RCache.set_Element(s_blur->E[2]);
-	RCache.set_c("blur_params", 1.0, 0.0, w, h);	
+	RCache.set_c("blur_params", 1.0, 0.0, w, h);
 	RCache.set_Geometry(g_combine);
 	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
-///////////////////////////////////////////////////////////////////////////////////
-////Final blur
-///////////////////////////////////////////////////////////////////////////////////
+	///////////////////////////////////////////////////////////////////////////////////
+	////Final blur
+	///////////////////////////////////////////////////////////////////////////////////
 	u_setrt(rt_blur_4, 0, 0, HW.pBaseZB);
 	RCache.set_CullMode(CULL_NONE);
 	RCache.set_Stencil(FALSE);
@@ -104,15 +106,15 @@ void CRenderTarget::phase_blur()
 
 	// Draw COLOR
 	RCache.set_Element(s_blur->E[3]);
-	RCache.set_c("blur_params", 0.0, 1.0, w, h);	
+	RCache.set_c("blur_params", 0.0, 1.0, w, h);
 	RCache.set_Geometry(g_combine);
 	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
-///////////////////////////////////////////////////////////////////////////////////
-////Horizontal blur
-///////////////////////////////////////////////////////////////////////////////////
+	///////////////////////////////////////////////////////////////////////////////////
+	////Horizontal blur
+	///////////////////////////////////////////////////////////////////////////////////
 	w = float(Device.dwWidth) * 0.125f;
 	h = float(Device.dwHeight) * 0.125f;
-	
+
 	u_setrt(rt_blur_h_8, 0, 0, HW.pBaseZB);
 	RCache.set_CullMode(CULL_NONE);
 	RCache.set_Stencil(FALSE);
@@ -127,12 +129,12 @@ void CRenderTarget::phase_blur()
 
 	// Draw COLOR
 	RCache.set_Element(s_blur->E[4]);
-	RCache.set_c("blur_params", 1.0, 0.0, w, h);	
+	RCache.set_c("blur_params", 1.0, 0.0, w, h);
 	RCache.set_Geometry(g_combine);
 	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
-///////////////////////////////////////////////////////////////////////////////////
-////Final blur
-///////////////////////////////////////////////////////////////////////////////////
+	///////////////////////////////////////////////////////////////////////////////////
+	////Final blur
+	///////////////////////////////////////////////////////////////////////////////////
 	u_setrt(rt_blur_8, 0, 0, HW.pBaseZB);
 	RCache.set_CullMode(CULL_NONE);
 	RCache.set_Stencil(FALSE);
@@ -147,8 +149,393 @@ void CRenderTarget::phase_blur()
 
 	// Draw COLOR
 	RCache.set_Element(s_blur->E[5]);
-	RCache.set_c("blur_params", 0.0, 1.0, w, h);		
+	RCache.set_c("blur_params", 0.0, 1.0, w, h);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+	///////////////////////////////////////////////////////////////////////////////////
+};
+
+#if defined(USE_DX11)
+
+void CRenderTarget::phase_ssfx_ssr()
+{
+	//Constants
+	u32 Offset = 0;
+	u32 C = color_rgba(0, 0, 0, 255);
+
+	float d_Z = EPS_S;
+	float d_W = 1.0f;
+	float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	float ScaleFactor = std::min(std::max(ps_ssfx_ssr.x, 1.0f), 2.0f);
+
+	Fvector2 p0, p1;
+	p0.set(0.0f, 0.0f);
+	p1.set(1.0f, 1.0f);
+
+
+	// GLOSS /////////////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_temp3, 0, 0, HW.pBaseZB);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_ssr->E[5]);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+	///////////////////////////////////////////////////////////////////////////
+
+	p1.set(1.0f / ScaleFactor, 1.0f / ScaleFactor);
+
+	// Fill VB
+	float scale_X = w / ScaleFactor;
+	float scale_Y = h / ScaleFactor;
+
+	// SSR ///////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx, 0, 0, HW.pBaseZB);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	if (ScaleFactor > 1.0f)
+		set_viewport_size(HW.pContext, scale_X, scale_Y);
+
+	//Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	//Set pass
+	RCache.set_Element(s_ssfx_ssr->E[0]);
+	RCache.set_c("m_current", Matrix_current);
+	RCache.set_c("m_previous", Matrix_previous);
+	RCache.set_c("cam_pos", ::Random.randF(-1.0, 1.0), ::Random.randF(-1.0, 1.0), 0.0f, 0.0f);
+
+	RCache.set_c("ssr_setup", ps_ssfx_ssr);
 	RCache.set_Geometry(g_combine);
 	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
-///////////////////////////////////////////////////////////////////////////////////
-};
\ No newline at end of file
+
+	// COPY SSR RESULT ( ACC ) ////////////////////////////////////////////
+	HW.pContext->CopyResource(rt_ssfx_ssr->pTexture->surface_get(), rt_ssfx->pTexture->surface_get());
+
+	// Disable/Enable Blur if the value is <= 0
+	//if (ps_ssfx_ssr.y > 0 || ps_ssfx_ssr.x > 1.0)
+	{
+		// BLUR PHASE 1 //////////////////////////////////////////////////////////
+		u_setrt(rt_ssfx_temp, 0, 0, HW.pBaseZB);
+		RCache.set_CullMode(CULL_NONE);
+		RCache.set_Stencil(FALSE);
+
+		// Fill vertex buffer
+		pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+		pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+		pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+		pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+		pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+		RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+		// Draw COLOR
+		RCache.set_Element(s_ssfx_ssr->E[1]);
+		RCache.set_c("blur_params", 1.0, 0.0, scale_X, scale_Y);
+		RCache.set_c("ssr_setup", ps_ssfx_ssr);
+		RCache.set_Geometry(g_combine);
+		RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+
+		// BLUR PHASE 2 //////////////////////////////////////////////////////////
+		u_setrt(rt_ssfx_temp2, 0, 0, HW.pBaseZB);
+		RCache.set_CullMode(CULL_NONE);
+		RCache.set_Stencil(FALSE);
+
+		// Fill vertex buffer
+		pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+		pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+		pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+		pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+		pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+		RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+		// Draw COLOR
+		RCache.set_Element(s_ssfx_ssr->E[2]);
+		RCache.set_c("blur_params", 0.0, 1.0, w, h);
+		RCache.set_c("ssr_setup", ps_ssfx_ssr);
+		RCache.set_Geometry(g_combine);
+		RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+	}
+
+	// COMBINE //////////////////////////////////////////////////////////
+	// Reset Viewport
+	if (ScaleFactor > 1.0f)
+		set_viewport_size(HW.pContext, w, h);
+
+	p1.set(1.0f, 1.0f);
+
+	if (!RImplementation.o.dx10_msaa)
+		u_setrt(rt_Generic_0, nullptr, nullptr, nullptr);
+	else
+		u_setrt(rt_Generic_0_r, nullptr, nullptr, nullptr);
+
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_ssr->E[3]);
+	RCache.set_c("ssr_setup", ps_ssfx_ssr);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+};
+
+void CRenderTarget::phase_ssfx_volumetric_blur()
+{
+	//Constants
+	u32 Offset = 0;
+	u32 C = color_rgba(0, 0, 0, 255);
+
+	float d_Z = EPS_S;
+	float d_W = 1.0f;
+	float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	float ScaleFactor = ps_ssfx_volumetric.w;
+
+	Fvector2 p0, p1;
+	p0.set(0.0f, 0.0f);
+	p1.set(1.0f / ScaleFactor, 1.0f / ScaleFactor);
+
+	// Scale Viewport
+	if (ScaleFactor > 1.0)
+		set_viewport_size(HW.pContext, w / ScaleFactor, h / ScaleFactor);
+
+	FLOAT ColorRGBA[4] = { 0.0f, 0.0f, 0.0f, 0.0f };
+	HW.pContext->ClearRenderTargetView(rt_ssfx_accum->pRT, ColorRGBA);
+
+	// BLUR PHASE 1 //////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_accum, 0, 0, NULL); //!RImplementation.o.dx10_msaa ? HW.pBaseZB : rt_MSAADepth->pZRT
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_volumetric_blur->E[0]);
+	RCache.set_c("blur_setup", w, h, 0, 2);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, w, h, 0, 2);
+
+
+	// BLUR PHASE 2 //////////////////////////////////////////////////////////
+	u_setrt(rt_Generic_2, 0, 0, NULL);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_volumetric_blur->E[1]);
+	RCache.set_c("blur_setup", w, h, 1, 0.5);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, w, h, 0, 2);
+
+
+	// BLUR PHASE 3 //////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_accum, 0, 0, NULL);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_volumetric_blur->E[0]);
+	RCache.set_c("blur_setup", w, h, 1, 2.0f);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+
+	// BLUR PHASE 4 //////////////////////////////////////////////////////////
+	u_setrt(rt_Generic_2, 0, 0, NULL);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_volumetric_blur->E[1]);
+	RCache.set_c("blur_setup", w, h, 2, 0.5f);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+	// Restore Viewport
+	if (ScaleFactor > 1.0f)
+		set_viewport_size(HW.pContext, w, h);
+
+};
+
+void CRenderTarget::phase_ssfx_water_blur()
+{
+	//Constants
+	u32 Offset = 0;
+	u32 C = color_rgba(0, 0, 0, 255);
+
+	float d_Z = EPS_S;
+	float d_W = 1.0f;
+	float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	Fvector2 p0, p1;
+	p0.set(0.0f, 0.0f);
+	p1.set(0.5f, 0.5f);
+
+	set_viewport_size(HW.pContext, w / 2, h / 2);
+
+	if (ps_ssfx_water.y > 0)
+	{
+		// BLUR PHASE 1 //////////////////////////////////////////////////////////
+		u_setrt(rt_ssfx_temp2, 0, 0, NULL);
+		RCache.set_CullMode(CULL_NONE);
+		RCache.set_Stencil(FALSE);
+
+		// Fill vertex buffer
+		FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+		pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+		pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+		pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+		pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+		RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+		// Draw COLOR
+		RCache.set_Element(s_ssfx_volumetric_blur->E[2]);
+		RCache.set_c("blur_setup", 1, 0, 0, 2.0f / ps_ssfx_water.x);
+		RCache.set_Geometry(g_combine);
+		RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+		// BLUR PHASE 2 //////////////////////////////////////////////////////////
+		u_setrt(rt_ssfx_temp, 0, 0, NULL);
+		RCache.set_CullMode(CULL_NONE);
+		RCache.set_Stencil(FALSE);
+
+		// Fill vertex buffer
+		pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+		pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+		pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+		pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+		pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+		RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+		// Draw COLOR
+		RCache.set_Element(s_ssfx_volumetric_blur->E[3]);
+		RCache.set_c("blur_setup", 0, 1, 0, 1.0f);
+
+		RCache.set_Geometry(g_combine);
+		RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+	}
+	else
+	{
+		HW.pContext->CopyResource(rt_ssfx_temp2->pTexture->surface_get(), rt_ssfx_temp->pTexture->surface_get());
+
+		u_setrt(rt_ssfx_temp, 0, 0, NULL);
+		RCache.set_CullMode(CULL_NONE);
+		RCache.set_Stencil(FALSE);
+
+		// Fill vertex buffer
+		FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+		pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+		pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+		pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+		pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+		RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+		// Draw COLOR
+		RCache.set_Element(s_ssfx_volumetric_blur->E[4]);
+		RCache.set_c("blur_setup", 0, 0, 0, 2.0f / ps_ssfx_water.x);
+		RCache.set_Geometry(g_combine);
+		RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+	}
+
+	set_viewport_size(HW.pContext, w, h);
+	p1.set(1.0f, 1.0f);
+
+};
+
+void CRenderTarget::phase_ssfx_water_waves()
+{
+	//Constants
+	u32 Offset = 0;
+	u32 C = color_rgba(0, 0, 0, 255);
+
+	float d_Z = EPS_S;
+	float d_W = 1.0f;
+	u32 w = Device.dwWidth;
+	u32 h = Device.dwHeight;
+
+
+	Fvector2 p0, p1;
+	p0.set(0.0f, 0.0f);
+	p1.set(1.0f, 1.0f);
+
+	set_viewport_size(HW.pContext, 512, 512);
+
+	u_setrt(rt_ssfx_water_waves, 0, 0, NULL);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_volumetric_blur->E[5]);
+	RCache.set_c("wind_setup", g_pGamePersistent->Environment().wind_anim.w, g_pGamePersistent->Environment().CurrentEnv->wind_velocity, 0, 0);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+	set_viewport_size(HW.pContext, w, h);
+};
+
+#endif
diff --git a/src/Layers/xrRender/xrRender_console.cpp b/src/Layers/xrRender/xrRender_console.cpp
index 19cf561..215dc09 100644
--- a/src/Layers/xrRender/xrRender_console.cpp
+++ b/src/Layers/xrRender/xrRender_console.cpp
@@ -292,6 +292,70 @@ Fvector4 ps_dev_param_8 = { .0f, .0f, .0f, .0f };
 
 /////////////////////////////////
 
+// Screen Space Shaders Stuff
+float ps_ssfx_hud_hemi = 0.15f; // HUD Hemi Offset
+
+int ps_ssfx_il_quality = 32; // IL Samples
+Fvector4 ps_ssfx_il = { 6.66f, 1.0f, 1.0f, 5.0f }; // Res, Int, Vibrance, Blur
+Fvector4 ps_ssfx_il_setup1 = { 150.0f, 1.0f, 0.5f, 0.0f }; // Distance, HUD, Flora, -
+
+int ps_ssfx_ao_quality = 4; // AO Samples
+Fvector4 ps_ssfx_ao = { 1.0f, 5.0f, 1.0f, 2.5f }; // Res, AO int, Blur, Radius
+Fvector4 ps_ssfx_ao_setup1 = { 150.0, 1.0, 1.0, 0.0 }; // Distance, HUD, Flora, Max OCC
+
+Fvector4 ps_ssfx_water = { 1.0f, 0.8f, 1.0f, 0.0f }; // Res, Blur, Blur Perlin, -
+Fvector3 ps_ssfx_water_quality = { 1.0, 2.0, 0.0 }; // SSR Quality, Parallax Quality, -
+Fvector4 ps_ssfx_water_setup1 = { 0.6f, 3.0f, 0.3f, 0.05f }; // Distortion, Turbidity, Softborder, Parallax Height
+Fvector4 ps_ssfx_water_setup2 = { 0.8f, 6.0f, 0.3f, 0.5f }; // Reflection, Specular, Caustics, Ripples
+
+int ps_ssfx_ssr_quality = 0; // Quality
+Fvector4 ps_ssfx_ssr = { 1.0f, 0.2f, 0.0f, 0.0f }; // Res, Blur, Temp, Noise
+Fvector4 ps_ssfx_ssr_2 = { 0.0f, 1.3f, 1.0f, 0.015f }; // Quality, Fade, Int, Wpn Int
+
+Fvector4 ps_ssfx_terrain_quality = { 6, 0, 0, 0 };
+Fvector4 ps_ssfx_terrain_offset = { 0, 0, 0, 0 };
+
+Fvector3 ps_ssfx_shadows = { 256, 1536, 0.0f };
+Fvector4 ps_ssfx_volumetric = { 0, 1.0f, 3.0f, 8.0f };
+
+Fvector3 ps_ssfx_shadow_bias = { 0.4f, 0.03f, 0.0f };
+
+Fvector4 ps_ssfx_lut = { 0.0f, 0.0f, 0.0f, 0.0f };
+
+Fvector4 ps_ssfx_wind_grass = { 9.5f, 1.4f, 1.5f, 0.4f };
+Fvector4 ps_ssfx_wind_trees = { 11.0f, 0.15f, 0.5f, 0.15f };
+
+Fvector4 ps_ssfx_florafixes_1 = { 0.3f, 0.21f, 0.3f, 0.21f }; // Flora fixes 1
+Fvector4 ps_ssfx_florafixes_2 = { 2.0f, 1.0f, 0.0f, 0.0f }; // Flora fixes 2
+
+Fvector4 ps_ssfx_wetsurfaces_1 = { 1.0f, 1.0f, 1.0f, 1.0f }; // Wet surfaces 1
+Fvector4 ps_ssfx_wetsurfaces_2 = { 1.0f, 1.0f, 1.0f, 1.0f }; // Wet surfaces 2
+
+int ps_ssfx_is_underground = 0;
+int ps_ssfx_gloss_method = 0;
+float ps_ssfx_gloss_factor = 0.5f;
+Fvector3 ps_ssfx_gloss_minmax = { 0.0f,0.92f,0.0f }; // Gloss
+
+Fvector4 ps_ssfx_lightsetup_1 = { 0.35f, 0.5f, 0.0f, 0.0f }; // Spec intensity
+
+Fvector4 ps_ssfx_hud_drops_1 = { 1.0f, 1.0f, 1.0f, 1.0f }; // Anim Speed, Int, Reflection, Refraction
+Fvector4 ps_ssfx_hud_drops_2 = { 1.5f, 0.85f, 0.0f, 2.0f }; // Density, Size, Extra Gloss, Gloss
+
+Fvector4 ps_ssfx_blood_decals = { 0.6f, 0.6f, 0.f, 0.f };
+Fvector4 ps_ssfx_rain_1 = { 2.0f, 0.1f, 0.6f, 2.f }; // Len, Width, Speed, Quality
+Fvector4 ps_ssfx_rain_2 = { 0.5f, 0.1f, 1.0f, 0.5f }; // Alpha, Brigthness, Refraction, Reflection
+Fvector4 ps_ssfx_rain_3 = { 0.5f, 1.0f, 0.0f, 0.0f }; // Alpha, Refraction ( Splashes )
+
+Fvector3 ps_ssfx_shadow_cascades = { 20, 40, 160 };
+Fvector4 ps_ssfx_grass_shadows = { .0f, .35f, 30.0f, .0f };
+
+Fvector4 ps_ssfx_grass_interactive = { .0f, .0f, 2000.0f, 1.0f };
+Fvector4 ps_ssfx_int_grass_params_1 = { 1.0f, 1.0f, 1.0f, 25.0f };
+Fvector4 ps_ssfx_int_grass_params_2 = { 1.0f, 5.0f, 1.0f, 1.0f };
+
+Fvector4 ps_ssfx_wpn_dof_1 = { .0f, .0f, .0f, .0f };
+float ps_ssfx_wpn_dof_2 = 1.0f;
+
 //	x - min (0), y - focus (1.4), z - max (100)
 Fvector3 ps_r2_dof = { -1.25f, 0.f, 600.f };
 float ps_r2_dof_sky = 30; //	distance to sky
@@ -347,6 +411,33 @@ int opt_dynamic = 2;
 #include "../xrRenderDX10/StateManager/dx10SamplerStateCache.h"
 #endif	//	USE_DX10
 
+class CCC_ssfx_cascades : public CCC_Vector3
+{
+public:
+	void apply()
+	{
+#if defined(USE_DX10) || defined(USE_DX11)
+		RImplementation.init_cacades();
+#endif
+	}
+
+	CCC_ssfx_cascades(LPCSTR N, Fvector3* V, const Fvector3 _min, const Fvector3 _max) : CCC_Vector3(N, V, _min, _max)
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Vector3::Execute(args);
+		apply();
+	}
+
+	virtual void Status(TStatus& S)
+	{
+		CCC_Vector3::Status(S);
+		apply();
+	}
+};
+
 //-----------------------------------------------------------------------
 //AVO: detail draw radius
 #ifdef DETAIL_RADIUS
@@ -962,7 +1053,7 @@ void xrRender_initconsole()
 	CMD4(CCC_Float, "r2_ls_dsm_kernel", &ps_r2_ls_dsm_kernel, .1f, 3.f);
 	CMD4(CCC_Float, "r2_ls_psm_kernel", &ps_r2_ls_psm_kernel, .1f, 3.f);
 	CMD4(CCC_Float, "r2_ls_ssm_kernel", &ps_r2_ls_ssm_kernel, .1f, 3.f);
-	CMD4(CCC_Float, "r2_ls_squality", &ps_r2_ls_squality, .5f, 1.f);
+	CMD4(CCC_Float, "r2_ls_squality", &ps_r2_ls_squality, .5f, 3.f);
 
 	CMD3(CCC_Mask, "r2_zfill", &ps_r2_ls_flags, R2FLAG_ZFILL);
 	CMD4(CCC_Float, "r2_zfill_depth", &ps_r2_zfill, .001f, .5f);
@@ -1070,6 +1161,71 @@ void xrRender_initconsole()
 	CMD4(CCC_Vector4, "shader_param_6", &ps_dev_param_6, tw2_min, tw2_max);
 	CMD4(CCC_Vector4, "shader_param_7", &ps_dev_param_7, tw2_min, tw2_max);
 	CMD4(CCC_Vector4, "shader_param_8", &ps_dev_param_8, tw2_min, tw2_max);
+	
+	// Screen Space Shaders
+	CMD4(CCC_Float, "ssfx_hud_hemi", &ps_ssfx_hud_hemi, 0.0f, 1.0f);
+
+	CMD4(CCC_Integer, "ssfx_il_quality", &ps_ssfx_il_quality, 16, 64);
+	CMD4(CCC_Vector4, "ssfx_il", &ps_ssfx_il, Fvector4().set(0, 0, 0, 0), Fvector4().set(8, 10, 3, 6));
+	CMD4(CCC_Vector4, "ssfx_il_setup1", &ps_ssfx_il_setup1, Fvector4().set(0, 0, 0, 0), Fvector4().set(300, 1, 1, 1));
+
+	CMD4(CCC_Integer, "ssfx_ao_quality", &ps_ssfx_ao_quality, 2, 8);
+	CMD4(CCC_Vector4, "ssfx_ao", &ps_ssfx_ao, Fvector4().set(0, 0, 0, 0), Fvector4().set(8, 10, 1, 10));
+	CMD4(CCC_Vector4, "ssfx_ao_setup1", &ps_ssfx_ao_setup1, Fvector4().set(0, 0, 0, 0), Fvector4().set(300, 1, 1, 1));
+
+	CMD4(CCC_Vector4, "ssfx_water", &ps_ssfx_water, Fvector4().set(1, 0, 0, 0), Fvector4().set(8, 1, 1, 0));
+	CMD4(CCC_Vector3, "ssfx_water_quality", &ps_ssfx_water_quality, Fvector3().set(0, 0, 0), Fvector3().set(4, 3, 0));
+	CMD4(CCC_Vector4, "ssfx_water_setup1", &ps_ssfx_water_setup1, Fvector4().set(0, 0, 0, 0), Fvector4().set(2, 10, 1, 0.1));
+	CMD4(CCC_Vector4, "ssfx_water_setup2", &ps_ssfx_water_setup2, Fvector4().set(0, 0, 0, 0), Fvector4().set(1, 10, 1, 1));
+
+	CMD4(CCC_Integer, "ssfx_ssr_quality", &ps_ssfx_ssr_quality, 0, 5);
+	CMD4(CCC_Vector4, "ssfx_ssr", &ps_ssfx_ssr, Fvector4().set(1, 0, 0, 0), Fvector4().set(2, 1, 1, 1));
+	CMD4(CCC_Vector4, "ssfx_ssr_2", &ps_ssfx_ssr_2, Fvector4().set(0, 0, 0, 0), Fvector4().set(2, 2, 2, 2));
+	
+	CMD4(CCC_Vector4, "ssfx_terrain_quality", &ps_ssfx_terrain_quality, Fvector4().set(0, 0, 0, 0), Fvector4().set(12, 0, 0, 0));
+	CMD4(CCC_Vector4, "ssfx_terrain_offset", &ps_ssfx_terrain_offset, Fvector4().set(-1, -1, -1, -1), Fvector4().set(1, 1, 1, 1));
+
+	CMD4(CCC_Vector3, "ssfx_shadows", &ps_ssfx_shadows, Fvector3().set(128, 1536, 0), Fvector3().set(1536, 4096, 0));
+	CMD4(CCC_Vector4, "ssfx_volumetric", &ps_ssfx_volumetric, Fvector4().set(0, 0, 1.0, 1.0), Fvector4().set(1.0, 5.0, 5.0, 16.0));
+
+	CMD4(CCC_Vector3, "ssfx_shadow_bias", &ps_ssfx_shadow_bias, Fvector3().set(0, 0, 0), Fvector3().set(1.0, 1.0, 1.0));
+
+	CMD4(CCC_Vector4, "ssfx_lut", &ps_ssfx_lut, Fvector4().set(0.0, 0.0, 0.0, 0.0), tw2_max);
+
+	CMD4(CCC_Vector4, "ssfx_wind_grass", &ps_ssfx_wind_grass, Fvector4().set(0.0, 0.0, 0.0, 0.0), Fvector4().set(20.0, 5.0, 5.0, 5.0));
+	CMD4(CCC_Vector4, "ssfx_wind_trees", &ps_ssfx_wind_trees, Fvector4().set(0.0, 0.0, 0.0, 0.0), Fvector4().set(20.0, 5.0, 5.0, 1.0));
+
+	CMD4(CCC_Vector4, "ssfx_florafixes_1", &ps_ssfx_florafixes_1, Fvector4().set(0.0, 0.0, 0.0, 0.0), Fvector4().set(1.0, 1.0, 1.0, 1.0));
+	CMD4(CCC_Vector4, "ssfx_florafixes_2", &ps_ssfx_florafixes_2, Fvector4().set(0.0, 0.0, 0.0, 0.0), Fvector4().set(10.0, 1.0, 1.0, 1.0));
+
+	CMD4(CCC_Vector4, "ssfx_wetsurfaces_1", &ps_ssfx_wetsurfaces_1, Fvector4().set(0.01, 0.01, 0.01, 0.01), Fvector4().set(2.0, 2.0, 2.0, 2.0));
+	CMD4(CCC_Vector4, "ssfx_wetsurfaces_2", &ps_ssfx_wetsurfaces_2, Fvector4().set(0.01, 0.01, 0.01, 0.01), Fvector4().set(2.0, 2.0, 2.0, 2.0));
+
+	CMD4(CCC_Integer, "ssfx_is_underground", &ps_ssfx_is_underground, 0, 1);
+	CMD4(CCC_Integer, "ssfx_gloss_method", &ps_ssfx_gloss_method, 0, 1);
+	CMD4(CCC_Vector3, "ssfx_gloss_minmax", &ps_ssfx_gloss_minmax, Fvector3().set(0, 0, 0), Fvector3().set(1.0, 1.0, 1.0));
+	CMD4(CCC_Float, "ssfx_gloss_factor", &ps_ssfx_gloss_factor, 0.0f, 1.0f);
+
+	CMD4(CCC_Vector4, "ssfx_lightsetup_1", &ps_ssfx_lightsetup_1, Fvector4().set(0, 0, 0, 0), Fvector4().set(1.0, 1.0, 1.0, 1.0));
+
+	CMD4(CCC_Vector4, "ssfx_hud_drops_1", &ps_ssfx_hud_drops_1, Fvector4().set(0, 0, 0, 0), Fvector4().set(100000, 100, 100, 100));
+	CMD4(CCC_Vector4, "ssfx_hud_drops_2", &ps_ssfx_hud_drops_2, Fvector4().set(0, 0, 0, 0), tw2_max);
+
+	CMD4(CCC_Vector4, "ssfx_blood_decals", &ps_ssfx_blood_decals, Fvector4().set(0, 0, 0, 0), Fvector4().set(5, 5, 0, 0));
+
+	CMD4(CCC_Vector4, "ssfx_rain_1", &ps_ssfx_rain_1, Fvector4().set(0, 0, 0, 0), Fvector4().set(10, 5, 5, 2));
+	CMD4(CCC_Vector4, "ssfx_rain_2", &ps_ssfx_rain_2, Fvector4().set(0, 0, 0, 0), Fvector4().set(1, 10, 10, 10));
+	CMD4(CCC_Vector4, "ssfx_rain_3", &ps_ssfx_rain_3, Fvector4().set(0, 0, 0, 0), Fvector4().set(1, 10, 10, 10));
+
+	CMD4(CCC_Vector4, "ssfx_grass_shadows", &ps_ssfx_grass_shadows, Fvector4().set(0, 0, 0, 0), Fvector4().set(3, 1, 100, 100));
+	CMD4(CCC_ssfx_cascades, "ssfx_shadow_cascades", &ps_ssfx_shadow_cascades, Fvector3().set(1.0f, 1.0f, 1.0f), Fvector3().set(300, 300, 300));
+	
+	CMD4(CCC_Vector4, "ssfx_grass_interactive", &ps_ssfx_grass_interactive, Fvector4().set(0, 0, 0, 0), Fvector4().set(1, 15, 5000, 1));
+	CMD4(CCC_Vector4, "ssfx_int_grass_params_1", &ps_ssfx_int_grass_params_1, Fvector4().set(0, 0, 0, 0), Fvector4().set(5, 5, 5, 60));
+	CMD4(CCC_Vector4, "ssfx_int_grass_params_2", &ps_ssfx_int_grass_params_2, Fvector4().set(0, 0, 0, 0), Fvector4().set(5, 20, 1, 5));
+	
+	CMD4(CCC_Vector4, "ssfx_wpn_dof_1", &ps_ssfx_wpn_dof_1, tw2_min, tw2_max);
+	CMD4(CCC_Float, "ssfx_wpn_dof_2", &ps_ssfx_wpn_dof_2, 0, 1);
 
 	// Geometry optimization
 	CMD4(CCC_Integer, "r__optimize_static_geom", &opt_static, 0, 4);
diff --git a/src/Layers/xrRender/xrRender_console.h b/src/Layers/xrRender/xrRender_console.h
index 7ee8c11..7c71d4d 100644
--- a/src/Layers/xrRender/xrRender_console.h
+++ b/src/Layers/xrRender/xrRender_console.h
@@ -3,6 +3,32 @@
 #pragma once
 
 // Common
+extern ECORE_API int ps_ssfx_il_quality;
+extern ECORE_API int ps_ssfx_ao_quality;
+extern ECORE_API Fvector3 ps_ssfx_water_quality;
+extern ECORE_API Fvector4 ps_ssfx_il;
+extern ECORE_API Fvector4 ps_ssfx_ao;
+extern ECORE_API Fvector4 ps_ssfx_water;
+
+extern ECORE_API int ps_ssfx_ssr_quality;
+extern ECORE_API Fvector4 ps_ssfx_ssr;
+extern ECORE_API Fvector4 ps_ssfx_ssr_2;
+extern ECORE_API Fvector4 ps_ssfx_terrain_quality;
+extern ECORE_API Fvector3 ps_ssfx_shadows;
+extern ECORE_API Fvector4 ps_ssfx_volumetric;
+
+extern ECORE_API Fvector4 ps_ssfx_wind_grass;
+extern ECORE_API Fvector4 ps_ssfx_wind_trees;
+
+extern ECORE_API Fvector4 ps_ssfx_rain_1;
+extern ECORE_API Fvector4 ps_ssfx_rain_2;
+extern ECORE_API Fvector4 ps_ssfx_rain_3;
+extern ECORE_API Fvector4 ps_ssfx_grass_shadows;
+extern ECORE_API Fvector3 ps_ssfx_shadow_cascades;
+extern ECORE_API Fvector4 ps_ssfx_grass_interactive;
+extern ECORE_API Fvector4 ps_ssfx_int_grass_params_1;
+extern ECORE_API Fvector4 ps_ssfx_int_grass_params_2;
+
 extern ECORE_API u32 ps_r_sun_shafts; //=	0;
 extern ECORE_API xr_token qsun_shafts_token[];
 
diff --git a/src/Layers/xrRenderDX10/Blender_Recorder_R3.cpp b/src/Layers/xrRenderDX10/Blender_Recorder_R3.cpp
index 356c58f..2283fc0 100644
--- a/src/Layers/xrRenderDX10/Blender_Recorder_R3.cpp
+++ b/src/Layers/xrRenderDX10/Blender_Recorder_R3.cpp
@@ -182,6 +182,18 @@ u32 CBlender_Compile::r_dx10Sampler(LPCSTR ResourceName)
 		i_dx10Filter(stage, D3DTEXF_POINT, D3DTEXF_NONE, D3DTEXF_POINT);
 	}
 
+	if (0 == xr_strcmp(ResourceName, "smp_linear2"))
+	{
+		i_dx10Address(stage, D3DTADDRESS_WRAP);
+		i_dx10Filter(stage, D3DTEXF_LINEAR, D3DTEXF_LINEAR, D3DTEXF_LINEAR);
+	}
+
+	if (0 == xr_strcmp(ResourceName, "smp_point"))
+	{
+		i_dx10Address(stage, D3DTADDRESS_WRAP);
+		i_dx10Filter(stage, D3DTEXF_POINT, D3DTEXF_POINT, D3DTEXF_POINT);
+	}
+
 	return stage;
 }
 
diff --git a/src/Layers/xrRenderDX10/DX10 Rain/dx10RainBlender.cpp b/src/Layers/xrRenderDX10/DX10 Rain/dx10RainBlender.cpp
index fed3190..9e4f11c 100644
--- a/src/Layers/xrRenderDX10/DX10 Rain/dx10RainBlender.cpp	
+++ b/src/Layers/xrRenderDX10/DX10 Rain/dx10RainBlender.cpp	
@@ -64,6 +64,9 @@ void CBlender_rain::Compile(CBlender_Compile& C)
 		//C.r_dx10Texture		("s_waterFall",	"water\\water_normal");
 		C.r_dx10Texture("s_waterFall", "water\\water_flowing_nmap");
 
+#if defined(USE_DX11)
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+#endif
 		C.r_End();
 
 		break;
diff --git a/src/Layers/xrRenderDX10/dx10DetailManager_VS.cpp b/src/Layers/xrRenderDX10/dx10DetailManager_VS.cpp
index bb08aa2..e26e3fe 100644
--- a/src/Layers/xrRenderDX10/dx10DetailManager_VS.cpp
+++ b/src/Layers/xrRenderDX10/dx10DetailManager_VS.cpp
@@ -110,6 +110,18 @@ void CDetailManager::hw_Render_dump(const Fvector4& consts, const Fvector4& wave
 	static shared_str strArray("array");
 	static shared_str strXForm("xform");
 
+	static shared_str strPos("benders_pos");
+	static shared_str strGrassSetup("benders_setup");
+
+	// Grass benders data
+	IGame_Persistent::grass_data& GData = g_pGamePersistent->grass_shader_data;
+	Fvector4 player_pos = { 0, 0, 0, 0 };
+	int BendersQty = _min(16, ps_ssfx_grass_interactive.y + 1);
+
+	// Add Player?
+	if (ps_ssfx_grass_interactive.x > 0)
+		player_pos.set(Device.vCameraPosition.x, Device.vCameraPosition.y, Device.vCameraPosition.z, -1);
+
 	Device.Statistic->RenderDUMP_DT_Count = 0;
 
 	// Matrices and offsets
@@ -146,6 +158,31 @@ void CDetailManager::hw_Render_dump(const Fvector4& consts, const Fvector4& wave
 				RCache.set_c(strDir2D, wind);
 				RCache.set_c(strXForm, Device.mFullTransform);
 
+				if (ps_ssfx_grass_interactive.y > 0)
+				{
+					RCache.set_c(strGrassSetup, ps_ssfx_int_grass_params_1);
+
+					Fvector4* c_grass;
+					{
+						void* GrassData;
+						RCache.get_ConstantDirect(strPos, BendersQty * sizeof(Fvector4) * 2, &GrassData, 0, 0);
+						c_grass = (Fvector4*)GrassData;
+					}
+					VERIFY(c_grass);
+
+					if (c_grass)
+					{
+						c_grass[0].set(player_pos);
+						c_grass[16].set(0.0f, -99.0f, 0.0f, 1.0f);
+
+						for (int Bend = 1; Bend < BendersQty; Bend++)
+						{
+							c_grass[Bend].set(GData.pos[Bend].x, GData.pos[Bend].y, GData.pos[Bend].z, GData.radius_curr[Bend]);
+							c_grass[Bend + 16].set(GData.dir[Bend].x, GData.dir[Bend].y, GData.dir[Bend].z, GData.str[Bend]);
+						}
+					}
+				}
+
 				//ref_constant constArray = RCache.get_c(strArray);
 				//VERIFY(constArray);
 
@@ -176,8 +213,20 @@ void CDetailManager::hw_Render_dump(const Fvector4& consts, const Fvector4& wave
 						SlotItem& Instance = **_iI;
 						u32 base = dwBatch * 4;
 
-						// Build matrix ( 3x4 matrix, last row - color )
 						float scale = Instance.scale_calculated;
+
+						// Sort of fade using the scale
+						// fade_distance == -1 use light_position to define "fade", anything else uses fade_distance
+						if (fade_distance <= -1)
+							scale *= 1.0f - Instance.position.distance_to_xz_sqr(light_position) * 0.005f;
+						else if (Instance.distance > fade_distance)
+							scale *= 1.0f - abs(Instance.distance - fade_distance) * 0.005f;
+
+						if (scale <= 0)
+							break;
+
+						// Build matrix ( 3x4 matrix, last row - color )
+						//float scale = Instance.scale_calculated;
 						Fmatrix& M = Instance.mRotY;
 						c_storage[base + 0].set(M._11 * scale, M._21 * scale, M._31 * scale, M._41);
 						c_storage[base + 1].set(M._12 * scale, M._22 * scale, M._32 * scale, M._42);
@@ -233,13 +282,16 @@ void CDetailManager::hw_Render_dump(const Fvector4& consts, const Fvector4& wave
 			}
 			// Clean up
 			// KD: we must not clear vis on r2 since we want details shadows
-			if (!psDeviceFlags2.test(rsGrassShadow) || ((ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_SMAP ==
+			if (ps_ssfx_grass_shadows.x <= 0)
+			{
+				if (!psDeviceFlags2.test(rsGrassShadow) || ((ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_SMAP ==
 					RImplementation.phase)) // phase smap with shadows
-				|| (ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_NORMAL == RImplementation.phase)
-					&& (!RImplementation.is_sun())) // phase normal with shadows without sun
-				|| (!ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_NORMAL == RImplementation.phase))
-			)) // phase normal without shadows
-				vis.clear_not_free();
+					|| (ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_NORMAL == RImplementation.phase)
+						&& (!RImplementation.is_sun())) // phase normal with shadows without sun
+					|| (!ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS) && (RImplementation.PHASE_NORMAL == RImplementation.phase))
+					)) // phase normal without shadows
+					vis.clear_not_free();
+			}
 		}
 		vOffset += hw_BatchSize * Object.number_vertices;
 		iOffset += hw_BatchSize * Object.number_indices;
diff --git a/src/Layers/xrRenderDX10/dx10ResourceManager_Resources.cpp b/src/Layers/xrRenderDX10/dx10ResourceManager_Resources.cpp
index 7259d3a..2f9d3dc 100644
--- a/src/Layers/xrRenderDX10/dx10ResourceManager_Resources.cpp
+++ b/src/Layers/xrRenderDX10/dx10ResourceManager_Resources.cpp
@@ -138,19 +138,21 @@ void CResourceManager::_DeletePass(const SPass* P)
 //--------------------------------------------------------------------------------------------------------------
 SVS* CResourceManager::_CreateVS(LPCSTR _name)
 {
+	int skinning = -1;
 	string_path name;
 	xr_strcpy(name, _name);
-	if (0 == ::Render->m_skinning) xr_strcat(name, "_0");
-	if (1 == ::Render->m_skinning) xr_strcat(name, "_1");
-	if (2 == ::Render->m_skinning) xr_strcat(name, "_2");
-	if (3 == ::Render->m_skinning) xr_strcat(name, "_3");
-	if (4 == ::Render->m_skinning) xr_strcat(name, "_4");
+	if (0 == ::Render->m_skinning) { xr_strcat(name, "_0"); skinning = 0; }
+	if (1 == ::Render->m_skinning) { xr_strcat(name, "_1"); skinning = 1; }
+	if (2 == ::Render->m_skinning) { xr_strcat(name, "_2"); skinning = 2; }
+	if (3 == ::Render->m_skinning) { xr_strcat(name, "_3"); skinning = 3; }
+	if (4 == ::Render->m_skinning) { xr_strcat(name, "_4"); skinning = 4; }
 	LPSTR N = LPSTR(name);
 	map_VS::iterator I = m_vs.find(N);
 	if (I != m_vs.end()) return I->second;
 	else
 	{
 		SVS* _vs = xr_new<SVS>();
+		_vs->skinning = skinning;
 		_vs->dwFlags |= xr_resource_flagged::RF_REGISTERED;
 		m_vs.insert(mk_pair(_vs->set_name(name), _vs));
 		//_vs->vs				= NULL;
diff --git a/src/Layers/xrRenderDX10/dx10ResourceManager_Scripting.cpp b/src/Layers/xrRenderDX10/dx10ResourceManager_Scripting.cpp
index 70d8640..71c984c 100644
--- a/src/Layers/xrRenderDX10/dx10ResourceManager_Scripting.cpp
+++ b/src/Layers/xrRenderDX10/dx10ResourceManager_Scripting.cpp
@@ -31,6 +31,12 @@ public:
 	{
 		return (RImplementation.o.dx10_msaa_alphatest == CRender::MSAA_ATEST_DX10_0_ATOC);
 	}
+
+	LPCSTR _get_level()
+	{
+		const shared_str level_name = g_pGameLevel->name();
+		return level_name.c_str();
+	}
 };
 
 // wrapper
@@ -193,6 +199,12 @@ public:
 		return *this;
 	}
 
+	adopt_compiler& _dx10CullMode(u32 Ref)
+	{
+		C->r_CullMode((D3DCULL)Ref);
+		return *this;
+	}
+
 	adopt_compiler& _dx10ATOC(bool Enable)
 	{
 		C->RS.SetRS(XRDX10RS_ALPHATOCOVERAGE, Enable);
@@ -344,6 +356,7 @@ void CResourceManager::LS_Load()
 	[
 		class_<adopt_dx10options>("_dx10options")
 		.def("dx10_msaa_alphatest_atoc", &adopt_dx10options::_dx10_msaa_alphatest_atoc)
+		.def("getLevel", &adopt_dx10options::_get_level)
 		//.def("",					&adopt_dx10options::_dx10Options		),	// returns options-object
 		,
 
@@ -389,6 +402,7 @@ void CResourceManager::LS_Load()
 		.def("dx10texture", &adopt_compiler::_dx10texture, return_reference_to(_1))
 		.def("dx10stencil", &adopt_compiler::_dx10Stencil, return_reference_to(_1))
 		.def("dx10stencil_ref", &adopt_compiler::_dx10StencilRef, return_reference_to(_1))
+		.def("dx10cullmode", &adopt_compiler::_dx10CullMode, return_reference_to(_1))
 		.def("dx10atoc", &adopt_compiler::_dx10ATOC, return_reference_to(_1))
 		.def("dx10zfunc", &adopt_compiler::_dx10ZFunc, return_reference_to(_1))
 
@@ -528,6 +542,16 @@ Shader* CResourceManager::_lua_Create(LPCSTR d_shader, LPCSTR s_textures)
 			C.bDetail = dxRenderDeviceRender::Instance().Resources->m_textures_description.GetDetailTexture(
 				C.L_textures[0], C.detail_texture, C.detail_scaler);
 			S.E[0] = C._lua_Compile(s_shader, "normal");
+			
+/// SSS fix water for DX10
+#if RENDER == R_R4
+			// Water Flag
+			if (S.E[0]->flags.bDistort)
+			{
+				if (strstr(s_shader, "effects_water"))
+					S.E[0]->flags.isWater = TRUE;
+			}
+#endif
 		}
 	}
 
diff --git a/src/Layers/xrRenderPC_R4/Light_Render_Direct_ComputeXFS.cpp b/src/Layers/xrRenderPC_R4/Light_Render_Direct_ComputeXFS.cpp
index 6b3c5dd..561543d 100644
--- a/src/Layers/xrRenderPC_R4/Light_Render_Direct_ComputeXFS.cpp
+++ b/src/Layers/xrRenderPC_R4/Light_Render_Direct_ComputeXFS.cpp
@@ -47,8 +47,9 @@ void CLight_Compute_XFORM_and_VIS::compute_xf_spot(light* L)
 	float intensity1 = (L->color.r * 0.2125f + L->color.g * 0.7154f + L->color.b * 0.0721f);
 	float intensity = (intensity0 + intensity1) / 2.f; // intensity1 tends to underestimate...
 
+	// [SSS 19] Improve this code later?
 	// compute how much duelling frusta occurs	[-1..1]-> 1 + [-0.5 .. +0.5]
-	float duel_dot = 1.f - 0.5f * Device.vCameraDirection.dotproduct(L_dir);
+	//float duel_dot = 1.f - 0.5f * Device.vCameraDirection.dotproduct(L_dir);
 
 	// compute how large the light is - give more texels to larger lights, assume 8m as being optimal radius
 	float sizefactor = L->range / 8.f; // 4m = .5, 8m=1.f, 16m=2.f, 32m=4.f
@@ -59,15 +60,17 @@ void CLight_Compute_XFORM_and_VIS::compute_xf_spot(light* L)
 	// factors
 	float factor0 = powf(ssa, 1.f / 2.f); // ssa is quadratic
 	float factor1 = powf(intensity, 1.f / 16.f); // less perceptually important?
-	float factor2 = powf(duel_dot, 1.f / 4.f); // difficult to fast-change this -> visible
+	//float factor2 = powf(duel_dot, 1.f / 4.f); // difficult to fast-change this -> visible
 	float factor3 = powf(sizefactor, 1.f / 4.f); // this shouldn't make much difference
 	float factor4 = powf(widefactor, 1.f / 2.f); // make it linear ???
-	float factor = ps_r2_ls_squality * factor0 * factor1 * factor2 * factor3 * factor4;
+	//float factor = ps_r2_ls_squality * factor0 * factor1 * factor2 * factor3 * factor4;
+	float factor = ps_r2_ls_squality * factor0 * factor1 * factor3 * factor4;
 
 	// final size calc
+	u32 max_size = RImplementation.o.smapsize <= ps_ssfx_shadows.y ? RImplementation.o.smapsize : ps_ssfx_shadows.y;
 	u32 _size = iFloor(factor * SMAP_adapt_optimal);
-	if (_size < SMAP_adapt_min) _size = SMAP_adapt_min;
-	if (_size > SMAP_adapt_max) _size = SMAP_adapt_max;
+	if (_size < ps_ssfx_shadows.x) _size = ps_ssfx_shadows.x;
+	if (_size > max_size) _size = max_size;
 	int _epsilon = iCeil(float(_size) * 0.01f);
 	int _diff = _abs(int(_size) - int(_cached_size));
 	L->X.S.size = (_diff >= _epsilon) ? _size : _cached_size;
@@ -87,11 +90,13 @@ void CLight_Compute_XFORM_and_VIS::compute_xf_spot(light* L)
 	
 	/* Ray Twitty */
 	float tan_shift;
-	if (L->flags.type == IRender_Light::POINT)	
-		tan_shift = deg2rad(11.5f);
-	else										
-		tan_shift = deg2rad(3.5f);
-	
+	if (L->flags.type == IRender_Light::OMNIPART) // [ SSS ] 0.3f fix almost all frustum problems... 0.5f was the old value ( SSS 19 ) but was causing issues?
+		tan_shift = 0.3f;
+	else if (L->flags.type == IRender_Light::POINT)
+		tan_shift = 0.2007129f; // deg2rad(11.5f);
+	else
+		tan_shift = 0.0610865f; //deg2rad(3.5f);
+
 	/* Ray Twitty end */
 	L->X.S.project.build_projection(L->cone + tan_shift, 1.f, L->virtual_size, L->range + EPS_S);
 	L->X.S.combine.mul(L->X.S.project, L->X.S.view);
diff --git a/src/Layers/xrRenderPC_R4/blender_blur.cpp b/src/Layers/xrRenderPC_R4/blender_blur.cpp
index f9aef21..4a7c63c 100644
--- a/src/Layers/xrRenderPC_R4/blender_blur.cpp
+++ b/src/Layers/xrRenderPC_R4/blender_blur.cpp
@@ -17,7 +17,7 @@ void CBlender_blur::Compile(CBlender_Compile& C)
 	case 0:	//Fullres Horizontal
 		C.r_Pass("stub_screen_space", "pp_blur", FALSE, FALSE, FALSE);
 		C.r_dx10Texture("s_image", r2_RT_generic0);
-		C.r_dx10Texture("s_position", r2_RT_P);		
+		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 
 		C.r_dx10Sampler("smp_nofilter");
@@ -27,7 +27,7 @@ void CBlender_blur::Compile(CBlender_Compile& C)
 	case 1:	//Fullres Vertical
 		C.r_Pass("stub_screen_space", "pp_blur", FALSE, FALSE, FALSE);
 		C.r_dx10Texture("s_image", r2_RT_blur_h_2);
-		C.r_dx10Texture("s_position", r2_RT_P);		
+		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 
 		C.r_dx10Sampler("smp_nofilter");
@@ -37,7 +37,7 @@ void CBlender_blur::Compile(CBlender_Compile& C)
 	case 2: //Halfres Horizontal
 		C.r_Pass("stub_screen_space", "pp_blur", FALSE, FALSE, FALSE);
 		C.r_dx10Texture("s_image", r2_RT_generic0);
-		C.r_dx10Texture("s_position", r2_RT_P);		
+		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 
 		C.r_dx10Sampler("smp_nofilter");
@@ -47,17 +47,17 @@ void CBlender_blur::Compile(CBlender_Compile& C)
 	case 3: //Halfres Vertical
 		C.r_Pass("stub_screen_space", "pp_blur", FALSE, FALSE, FALSE);
 		C.r_dx10Texture("s_image", r2_RT_blur_h_4);
-		C.r_dx10Texture("s_position", r2_RT_P);		
+		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
 		C.r_End();
-		break;		
+		break;
 	case 4: //Quarterres Horizontal
 		C.r_Pass("stub_screen_space", "pp_blur", FALSE, FALSE, FALSE);
 		C.r_dx10Texture("s_image", r2_RT_generic0);
-		C.r_dx10Texture("s_position", r2_RT_P);		
+		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 
 		C.r_dx10Sampler("smp_nofilter");
@@ -67,12 +67,282 @@ void CBlender_blur::Compile(CBlender_Compile& C)
 	case 5: //Quarterres Vertical
 		C.r_Pass("stub_screen_space", "pp_blur", FALSE, FALSE, FALSE);
 		C.r_dx10Texture("s_image", r2_RT_blur_h_8);
-		C.r_dx10Texture("s_position", r2_RT_P);		
+		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
 		C.r_End();
-		break;				
+		break;
+	}
+}
+
+
+CBlender_ssfx_ssr::CBlender_ssfx_ssr() { description.CLS = 0; }
+
+CBlender_ssfx_ssr::~CBlender_ssfx_ssr()
+{
+}
+
+void CBlender_ssfx_ssr::Compile(CBlender_Compile& C)
+{
+	IBlender::Compile(C);
+
+	switch (C.iElement)
+	{
+	case 0:	// Do SSR
+		C.r_Pass("stub_screen_space", "ssfx_ssr", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("s_position", r2_RT_P);
+		C.r_dx10Texture("ssr_image", r2_RT_ssfx_ssr); // Prev Frame
+		C.r_dx10Texture("s_rimage", "$user$generic_temp");
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+		C.r_dx10Texture("s_prev_pos", r2_RT_ssfx_prevPos);
+		C.r_dx10Texture("s_gloss_data", r2_RT_ssfx_temp3);
+
+		C.r_dx10Texture("blue_noise", "fx\\blue_noise");
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_rtlinear");
+		C.r_dx10Sampler("smp_linear");
+
+		C.r_End();
+		break;
+
+	case 1:	// Blur Phase 1
+		C.r_Pass("stub_screen_space", "ssfx_ssr_blur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("ssr_image", r2_RT_ssfx);
+		C.r_dx10Texture("s_diffuse", r2_RT_albedo);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_End();
+		break;
+
+	case 2:	// Blur Phase 2
+		C.r_Pass("stub_screen_space", "ssfx_ssr_blur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("ssr_image", r2_RT_ssfx_temp);
+		C.r_dx10Texture("s_diffuse", r2_RT_albedo);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_End();
+		break;
+
+	case 3:	// Combine
+		C.r_Pass("stub_screen_space", "ssfx_ssr_combine", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("s_position", r2_RT_P);
+		C.r_dx10Texture("s_rimage", "$user$generic_temp");
+
+		C.r_dx10Texture("ssr_image", r2_RT_ssfx_temp2);
+		C.r_dx10Texture("s_gloss_data", r2_RT_ssfx_temp3);
+
+		C.r_dx10Sampler("smp_linear");
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_End();
+
+		break;
+
+	case 4:	// No blur just direct to [r2_RT_ssfx_temp2]
+		C.r_Pass("stub_screen_space", "ssfx_ssr_noblur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("ssr_image", r2_RT_ssfx);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_End();
+		break;
+
+	case 5:
+		C.r_Pass("stub_screen_space", "ssfx_ssr_gloss", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("s_position", r2_RT_P);
+		C.r_dx10Texture("s_diffuse", r2_RT_albedo);
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Texture("env_s0", r2_T_envs0);
+		C.r_dx10Texture("env_s1", r2_T_envs1);
+		C.r_dx10Texture("sky_s0", r2_T_sky0);
+		C.r_dx10Texture("sky_s1", r2_T_sky1);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_End();
+		break;
+	}
+}
+
+
+
+CBlender_ssfx_volumetric_blur::CBlender_ssfx_volumetric_blur() { description.CLS = 0; }
+
+CBlender_ssfx_volumetric_blur::~CBlender_ssfx_volumetric_blur()
+{
+}
+
+void CBlender_ssfx_volumetric_blur::Compile(CBlender_Compile& C)
+{
+	IBlender::Compile(C);
+
+	switch (C.iElement)
+	{
+	case 0:	// Blur Phase 1
+		C.r_Pass("stub_screen_space", "ssfx_volumetric_blur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("vol_buffer", r2_RT_generic2);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_linear");
+		C.r_End();
+		break;
+
+	case 1:	// Blur Phase 2
+		C.r_Pass("stub_screen_space", "ssfx_volumetric_blur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("vol_buffer", r2_RT_ssfx_accum);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_linear");
+		C.r_End();
+		break;
+
+	case 2:	// Blur Phase 1
+		C.r_Pass("stub_screen_space", "ssfx_water_blur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("water_buffer", r2_RT_ssfx_temp);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_linear");
+		C.r_End();
+		break;
+
+	case 3:	// Blur Phase 2
+		C.r_Pass("stub_screen_space", "ssfx_water_blur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("water_buffer", r2_RT_ssfx_temp2);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_linear");
+		C.r_End();
+		break;
+
+	case 4:	// No Blur
+		C.r_Pass("stub_screen_space", "ssfx_water_noblur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("water_buffer", r2_RT_ssfx_temp2);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_linear");
+		C.r_End();
+		break;
+
+	case 5:	// Water Waves
+		C.r_Pass("stub_screen_space", "ssfx_water_waves", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("water_waves", "fx\\water_height");
+
+		C.r_dx10Sampler("smp_linear");
+		C.r_End();
+		break;
 	}
 }
+
+CBlender_ssfx_ao::CBlender_ssfx_ao() { description.CLS = 0; }
+
+CBlender_ssfx_ao::~CBlender_ssfx_ao()
+{
+}
+
+void CBlender_ssfx_ao::Compile(CBlender_Compile& C)
+{
+	IBlender::Compile(C);
+
+	switch (C.iElement)
+	{
+	case 0:	// AO
+		C.r_Pass("stub_screen_space", "ssfx_ao", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("s_position", r2_RT_P);
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+		C.r_dx10Texture("ssfx_ao", r2_RT_ssfx_ao);
+
+		C.r_dx10Texture("s_prev_pos", r2_RT_ssfx_prevPos);
+
+		C.r_dx10Texture("jitter0", JITTER(0));
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_linear");
+		C.r_dx10Sampler("smp_jitter");
+
+		C.r_End();
+
+		break;
+
+	case 1:	// Blur Phase 1
+		C.r_Pass("stub_screen_space", "ssfx_ao_blur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("ao_image", r2_RT_ssfx_temp);
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_linear");
+		C.r_End();
+		break;
+
+	case 2:	// Blur Phase 2
+		C.r_Pass("stub_screen_space", "ssfx_ao_blur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("ao_image", r2_RT_ssfx_temp3);
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_linear");
+		C.r_End();
+		break;
+
+
+	case 3:	// IL
+		C.r_Pass("stub_screen_space", "ssfx_il", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("s_accumulator", r2_RT_accum);
+		C.r_dx10Texture("s_position", r2_RT_P);
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Texture("ssfx_ao", r2_RT_ssfx_il);
+
+
+
+		C.r_dx10Texture("s_prev_pos", r2_RT_ssfx_prevPos);
+
+		C.r_dx10Texture("jitter0", JITTER(0));
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_linear");
+		C.r_dx10Sampler("smp_jitter");
+
+		C.r_End();
+
+		break;
+
+	case 4:	// Blur Phase 1
+		C.r_Pass("stub_screen_space", "ssfx_il_blur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("ao_image", r2_RT_ssfx_temp2);
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_linear");
+		C.r_End();
+		break;
+
+	case 5:	// Blur Phase 2
+		C.r_Pass("stub_screen_space", "ssfx_il_blur", FALSE, FALSE, FALSE);
+
+		C.r_dx10Texture("ao_image", r2_RT_ssfx_temp3);
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_linear");
+		C.r_End();
+		break;
+	}
+}
\ No newline at end of file
diff --git a/src/Layers/xrRenderPC_R4/blender_blur.h b/src/Layers/xrRenderPC_R4/blender_blur.h
index dc22291..d73e361 100644
--- a/src/Layers/xrRenderPC_R4/blender_blur.h
+++ b/src/Layers/xrRenderPC_R4/blender_blur.h
@@ -13,3 +13,43 @@ public:
 	CBlender_blur();
 	virtual ~CBlender_blur();
 };
+
+// SSS
+class CBlender_ssfx_ssr : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "ssfx_ssr"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_ssfx_ssr();
+	virtual ~CBlender_ssfx_ssr();
+};
+
+class CBlender_ssfx_volumetric_blur : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "ssfx_volumetric_blur"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_ssfx_volumetric_blur();
+	virtual ~CBlender_ssfx_volumetric_blur();
+};
+
+class CBlender_ssfx_ao : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "ssfx_ao"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_ssfx_ao();
+	virtual ~CBlender_ssfx_ao();
+};
\ No newline at end of file
diff --git a/src/Layers/xrRenderPC_R4/blender_combine.cpp b/src/Layers/xrRenderPC_R4/blender_combine.cpp
index 609667b..6406fba 100644
--- a/src/Layers/xrRenderPC_R4/blender_combine.cpp
+++ b/src/Layers/xrRenderPC_R4/blender_combine.cpp
@@ -17,7 +17,7 @@ void CBlender_combine::Compile(CBlender_Compile& C)
 	{
 	case 0: // combine
 		C.r_Pass("combine_1", "combine_1_nomsaa", FALSE, FALSE, FALSE, TRUE, D3DBLEND_INVSRCALPHA,
-		         D3DBLEND_SRCALPHA); //. MRT-blend?
+			D3DBLEND_SRCALPHA); //. MRT-blend?
 		C.r_Stencil(TRUE, D3DCMP_LESSEQUAL, 0xff, 0x00); // stencil should be >= 1
 		C.r_StencilRef(0x01);
 		//C.r_Sampler_rtf		("s_position",		r2_RT_P				);
@@ -45,8 +45,14 @@ void CBlender_combine::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_occ", r2_RT_ssao_temp);
 		C.r_dx10Texture("s_half_depth", r2_RT_half_depth);
 
+		C.r_dx10Texture("ssfx_ao", r2_RT_ssfx_temp);
+		C.r_dx10Texture("ssfx_il", r2_RT_ssfx_temp2);
+
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
 		jitter(C);
 
+		C.r_dx10Sampler("smp_linear");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_material");
 		C.r_dx10Sampler("smp_rtlinear");
@@ -63,15 +69,19 @@ void CBlender_combine::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_image", r2_RT_generic0);
 		C.r_dx10Texture("s_bloom", r2_RT_bloom1);
-		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);			
+		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
 		C.r_dx10Texture("s_distort", r2_RT_generic1);
 		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
 
+		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 		C.r_dx10Texture("s_lens_dirt", "shaders\\lens_dirt");
 		C.r_dx10Texture("s_noise_1", "shaders\\noise\\noise_tex");
 
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Sampler("smp_linear");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
 		C.r_End();
@@ -88,15 +98,19 @@ void CBlender_combine::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_image", r2_RT_generic0);
 		C.r_dx10Texture("s_bloom", r2_RT_bloom1);
-		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);			
+		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
 		C.r_dx10Texture("s_distort", r2_RT_generic1);
 		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
 
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 		C.r_dx10Texture("s_lens_dirt", "shaders\\lens_dirt");
 		C.r_dx10Texture("s_noise_1", "shaders\\noise\\noise_tex");
 
+		C.r_dx10Sampler("smp_linear");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
 		C.r_End();
@@ -112,15 +126,19 @@ void CBlender_combine::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_image", r2_RT_generic0);
 		C.r_dx10Texture("s_bloom", r2_RT_bloom1);
-		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);			
+		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
 		C.r_dx10Texture("s_distort", r2_RT_generic1);
 		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
 
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 		C.r_dx10Texture("s_lens_dirt", "shaders\\lens_dirt");
 		C.r_dx10Texture("s_noise_1", "shaders\\noise\\noise_tex");
 
+		C.r_dx10Sampler("smp_linear");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
 		C.r_End();
@@ -137,15 +155,19 @@ void CBlender_combine::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_image", r2_RT_generic0);
 		C.r_dx10Texture("s_bloom", r2_RT_bloom1);
-		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);	
+		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
 		C.r_dx10Texture("s_distort", r2_RT_generic1);
 		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
 
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 		C.r_dx10Texture("s_lens_dirt", "shaders\\lens_dirt");
 		C.r_dx10Texture("s_noise_1", "shaders\\noise\\noise_tex");
 
+		C.r_dx10Sampler("smp_linear");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
 		C.r_End();
@@ -175,7 +197,7 @@ void CBlender_combine_msaa::Compile(CBlender_Compile& C)
 	{
 	case 0: // combine
 		C.r_Pass("combine_1", "combine_1_msaa", FALSE, FALSE, FALSE, TRUE, D3DBLEND_INVSRCALPHA,
-		         D3DBLEND_SRCALPHA); //. MRT-blend?
+			D3DBLEND_SRCALPHA); //. MRT-blend?
 		C.r_Stencil(TRUE, D3DCMP_LESSEQUAL, 0xff, 0x00); // stencil should be >= 1
 		C.r_StencilRef(0x01);
 		//C.r_Sampler_rtf		("s_position",		r2_RT_P				);
@@ -203,8 +225,14 @@ void CBlender_combine_msaa::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("sky_s0", r2_T_sky0);
 		C.r_dx10Texture("sky_s1", r2_T_sky1);
 
+		C.r_dx10Texture("ssfx_ao", r2_RT_ssfx_temp);
+		C.r_dx10Texture("ssfx_il", r2_RT_ssfx_temp2);
+
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
 		jitter(C);
 
+		C.r_dx10Sampler("smp_linear");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_material");
 		C.r_dx10Sampler("smp_rtlinear");
@@ -221,15 +249,19 @@ void CBlender_combine_msaa::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_image", r2_RT_generic0);
 		C.r_dx10Texture("s_bloom", r2_RT_bloom1);
-		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);			
+		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
 		C.r_dx10Texture("s_distort", r2_RT_generic1_r);
 		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
-		
+
+		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 		C.r_dx10Texture("s_lens_dirt", "shaders\\lens_dirt");
 		C.r_dx10Texture("s_noise_1", "shaders\\noise\\noise_tex");
 
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Sampler("smp_linear");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
 		C.r_End();
@@ -246,15 +278,19 @@ void CBlender_combine_msaa::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_image", r2_RT_generic0);
 		C.r_dx10Texture("s_bloom", r2_RT_bloom1);
-		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);		
+		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
 		C.r_dx10Texture("s_distort", r2_RT_generic1_r);
 		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
 
+		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 		C.r_dx10Texture("s_lens_dirt", "shaders\\lens_dirt");
 		C.r_dx10Texture("s_noise_1", "shaders\\noise\\noise_tex");
 
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Sampler("smp_linear");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
 		C.r_End();
@@ -270,15 +306,19 @@ void CBlender_combine_msaa::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_image", r2_RT_generic0);
 		C.r_dx10Texture("s_bloom", r2_RT_bloom1);
-		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);			
+		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
 		C.r_dx10Texture("s_distort", r2_RT_generic1_r);
 		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
 
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 		C.r_dx10Texture("s_lens_dirt", "shaders\\lens_dirt");
 		C.r_dx10Texture("s_noise_1", "shaders\\noise\\noise_tex");
 
+		C.r_dx10Sampler("smp_linear");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
 		C.r_End();
@@ -295,15 +335,19 @@ void CBlender_combine_msaa::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_position", r2_RT_P);
 		C.r_dx10Texture("s_image", r2_RT_generic0);
 		C.r_dx10Texture("s_bloom", r2_RT_bloom1);
-		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);					
+		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
 		C.r_dx10Texture("s_distort", r2_RT_generic1_r);
 		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
 
+		C.r_dx10Texture("s_hud_mask", r2_RT_ssfx_hud);
+
+		C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 		C.r_dx10Texture("s_lens_dirt", "shaders\\lens_dirt");
 		C.r_dx10Texture("s_noise_1", "shaders\\noise\\noise_tex");
 
+		C.r_dx10Sampler("smp_linear");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
 		C.r_End();
diff --git a/src/Layers/xrRenderPC_R4/blender_deffer_model.cpp b/src/Layers/xrRenderPC_R4/blender_deffer_model.cpp
index 852818e..74ff68e 100644
--- a/src/Layers/xrRenderPC_R4/blender_deffer_model.cpp
+++ b/src/Layers/xrRenderPC_R4/blender_deffer_model.cpp
@@ -116,7 +116,13 @@ void CBlender_deffer_model::Compile(CBlender_Compile& C)
 				C.r_End();
 			}
 
-			uber_deffer(C, true, "model", "base", bAref, 0, true);
+			if (C.HudElement)
+			{
+				uber_deffer(C, true, "model_hud", "base_hud", bAref, 0, true);
+				C.r_dx10Texture("s_hud_rain", "fx\\hud_rain");
+			}
+			else
+				uber_deffer(C, true, "model", "base", bAref, 0, true);
 
 			C.r_Stencil(TRUE, D3DCMP_ALWAYS, 0xff, 0x7f, D3DSTENCILOP_KEEP, D3DSTENCILOP_REPLACE, D3DSTENCILOP_KEEP);
 			C.r_StencilRef(0x01);
diff --git a/src/Layers/xrRenderPC_R4/blender_lut.cpp b/src/Layers/xrRenderPC_R4/blender_lut.cpp
index 01a54cf..d3ffb0c 100644
--- a/src/Layers/xrRenderPC_R4/blender_lut.cpp
+++ b/src/Layers/xrRenderPC_R4/blender_lut.cpp
@@ -13,7 +13,11 @@ void CBlender_lut::Compile(CBlender_Compile& C)
 	IBlender::Compile(C);
 
 	C.r_Pass("stub_screen_space", "pp_lut", FALSE, FALSE, FALSE);
-	C.r_dx10Texture("s_image", r2_RT_generic0);
+	
+	C.r_dx10Texture("s_image", r2_RT_generic0);//  r2_RT_generic0
+	C.r_dx10Texture("debug_image", r2_RT_ssfx_hud);//  r2_RT_generic0
+	C.r_dx10Texture("debug_noise", "fx\\blue_noise");//  r2_RT_generic0
+
 	C.r_dx10Texture("s_lut_atlas", "shaders\\lut_atlas");
 
 	C.r_dx10Sampler("smp_base");
diff --git a/src/Layers/xrRenderPC_R4/light_vis.cpp b/src/Layers/xrRenderPC_R4/light_vis.cpp
index f4334ea..ce8e290 100644
--- a/src/Layers/xrRenderPC_R4/light_vis.cpp
+++ b/src/Layers/xrRenderPC_R4/light_vis.cpp
@@ -35,8 +35,11 @@ void light::vis_prepare()
 	bool skiptest = false;
 	if (ps_r2_ls_flags.test(R2FLAG_EXP_DONT_TEST_UNSHADOWED) && !flags.bShadow) skiptest = true;
 	if (ps_r2_ls_flags.test(R2FLAG_EXP_DONT_TEST_SHADOWED) && flags.bShadow) skiptest = true;
+	if (ps_ssfx_volumetric.x > 0 && flags.bShadow) skiptest = true; // Temp Fix
 
-	if (skiptest || Device.vCameraPosition.distance_to(spatial.sphere.P) <= (spatial.sphere.R * 1.01f + safe_area))
+	vis.distance = Device.vCameraPosition.distance_to(spatial.sphere.P);
+
+	if (skiptest || vis.distance <= (spatial.sphere.R * 1.01f + safe_area))
 	{
 		// small error
 		vis.visible = true;
diff --git a/src/Layers/xrRenderPC_R4/r2_R_lights.cpp b/src/Layers/xrRenderPC_R4/r2_R_lights.cpp
index a66b3e0..821ac3f 100644
--- a/src/Layers/xrRenderPC_R4/r2_R_lights.cpp
+++ b/src/Layers/xrRenderPC_R4/r2_R_lights.cpp
@@ -7,6 +7,24 @@ IC bool pred_area(light* _1, light* _2)
 	return a0 > a1; // reverse -> descending
 }
 
+bool check_grass_shadow(light* L, CFrustum VB)
+{
+	// Grass shadows are allowed?
+	if (ps_ssfx_grass_shadows.x < 3 || !psDeviceFlags2.test(rsGrassShadow))
+		return false;
+
+	// Inside the range?
+	if (L->vis.distance > ps_ssfx_grass_shadows.z)
+		return false;
+
+	// Is in view? L->vis.visible?
+	u32 mask = 0xff;
+	if (!VB.testSphere(L->position, L->range * 0.6f, mask))
+		return false;
+
+	return true;
+}
+
 void CRender::render_lights(light_Package& LP)
 {
 	//////////////////////////////////////////////////////////////////////////
@@ -117,6 +135,15 @@ void CRender::render_lights(light_Package& LP)
 				RCache.set_xform_view(L->X.S.view);
 				RCache.set_xform_project(L->X.S.project);
 				r_dsgraph_render_graph(0);
+				if (Details)
+				{
+					if (check_grass_shadow(L, ViewBase))
+					{
+						Details->fade_distance = -1; // Use light position to calc "fade"
+						Details->light_position.set(L->position);
+						Details->Render();
+					}
+				}
 				L->X.S.transluent = FALSE;
 				if (bSpecial)
 				{
@@ -187,8 +214,24 @@ void CRender::render_lights(light_Package& LP)
 
 			PIX_EVENT(ACCUM_VOLUMETRIC);
 			if (RImplementation.o.advancedpp && ps_r2_ls_flags.is(R2FLAG_VOLUMETRIC_LIGHTS))
+			{
+				// Current Resolution
+				float w = float(Device.dwWidth);
+				float h = float(Device.dwHeight);
+
+				// Adjust resolution
+				if (RImplementation.o.ssfx_volumetric && ps_ssfx_volumetric.w > 1)
+					Target->set_viewport_size(HW.pContext, w / ps_ssfx_volumetric.w, h / ps_ssfx_volumetric.w);
+
 				for (u32 it = 0; it < L_spot_s.size(); it++)
+				{
 					Target->accum_volumetric(L_spot_s[it]);
+				}
+				
+				// Restore resolution
+				if (RImplementation.o.ssfx_volumetric && ps_ssfx_volumetric.w > 1)
+					Target->set_viewport_size(HW.pContext, w, h);
+			}
 
 			L_spot_s.clear();
 		}
diff --git a/src/Layers/xrRenderPC_R4/r2_R_sun.cpp b/src/Layers/xrRenderPC_R4/r2_R_sun.cpp
index 7d6c6e9..2b0671c 100644
--- a/src/Layers/xrRenderPC_R4/r2_R_sun.cpp
+++ b/src/Layers/xrRenderPC_R4/r2_R_sun.cpp
@@ -1093,13 +1093,13 @@ void CRender::init_cacades()
 	float fBias = -0.0000025f;
 	//	float size = MAP_SIZE_START;
 	m_sun_cascades[0].reset_chain = true;
-	m_sun_cascades[0].size = 20; 
+	m_sun_cascades[0].size = ps_ssfx_shadow_cascades.x; //20
 	m_sun_cascades[0].bias = m_sun_cascades[0].size * fBias;
 
-	m_sun_cascades[1].size = 40;
+	m_sun_cascades[1].size = ps_ssfx_shadow_cascades.y; //40
 	m_sun_cascades[1].bias = m_sun_cascades[1].size * fBias;
 
-	m_sun_cascades[2].size = 160;
+	m_sun_cascades[2].size = ps_ssfx_shadow_cascades.z; //160
 	m_sun_cascades[2].bias = m_sun_cascades[2].size * fBias;
 
 	// 	for( u32 i = 0; i < cascade_count; ++i )
@@ -1384,8 +1384,11 @@ void CRender::render_sun_cascade(u32 cascade_ind)
 			RCache.set_xform_view(Fidentity);
 			RCache.set_xform_project(fuckingsun->X.D.combine);
 			r_dsgraph_render_graph(0);
-			if (ps_r2_ls_flags.test(R2FLAG_SUN_DETAILS))
+			if (psDeviceFlags2.test(rsGrassShadow) && cascade_ind <= ps_ssfx_grass_shadows.x)
+			{
+				Details->fade_distance = dm_fade * dm_fade * ps_ssfx_grass_shadows.y;
 				Details->Render();
+			}
 			fuckingsun->X.D.transluent = FALSE;
 			if (bSpecial)
 			{
diff --git a/src/Layers/xrRenderPC_R4/r2_types.h b/src/Layers/xrRenderPC_R4/r2_types.h
index 18a11d4..d81fb91 100644
--- a/src/Layers/xrRenderPC_R4/r2_types.h
+++ b/src/Layers/xrRenderPC_R4/r2_types.h
@@ -72,6 +72,21 @@
 #define		r2_RT_smaa_edgetex "$user$smaa_edgetex"
 #define		r2_RT_smaa_blendtex "$user$smaa_blendtex"
 
+#define		r2_RT_ssfx				"$user$ssfx" // SSS Temp1
+#define		r2_RT_ssfx_temp			"$user$ssfx_temp" // SSS Temp2
+#define		r2_RT_ssfx_temp2		"$user$ssfx_temp2" // SSS Temp3
+#define		r2_RT_ssfx_temp3		"$user$ssfx_temp3"
+#define		r2_RT_ssfx_accum		"$user$ssfx_accum" // SSS Volumetric
+#define		r2_RT_ssfx_hud			"$user$ssfx_hud" // HUD & Velocity Buffer
+
+#define		r2_RT_ssfx_ssr			"$user$ssfx_ssr" // SSR Acc
+#define		r2_RT_ssfx_water		"$user$ssfx_water" // Water Acc
+#define		r2_RT_ssfx_water_waves	"$user$ssfx_water_waves"
+#define		r2_RT_ssfx_ao			"$user$ssfx_ao" // AO Acc
+#define		r2_RT_ssfx_il			"$user$ssfx_il" // IL Acc
+
+#define		r2_RT_ssfx_prevPos		"$user$ssfx_prev_p" // Prev Position
+
 #define		JITTER(a) r2_jitter #a
 
 const float SMAP_near_plane = .1f;
@@ -121,10 +136,23 @@ const u32 LUMINANCE_size = 16;
 
 extern float ps_r2_gloss_factor;
 extern float ps_r2_gloss_min;
+
+extern int ps_ssfx_gloss_method;
+extern float ps_ssfx_gloss_factor;
+extern Fvector3 ps_ssfx_gloss_minmax;
+
 IC float u_diffuse2s(float x, float y, float z)
 {
-	float v = (x + y + z) / 3.f;
-	return ps_r2_gloss_min + ps_r2_gloss_factor * ((v < 1) ? powf(v, 2.f / 3.f) : v);
+	if (ps_ssfx_gloss_method == 0)
+	{
+		float v = (x + y + z) / 3.f;
+		return ps_r2_gloss_min + ps_r2_gloss_factor * ((v < 1) ? powf(v, 2.f / 3.f) : v);
+	}
+	else
+	{
+		// Remove sun from the equation and clamp value.
+		return ps_ssfx_gloss_minmax.x + clampr(ps_ssfx_gloss_minmax.y - ps_ssfx_gloss_minmax.x, 0.0f, 1.0f) * ps_ssfx_gloss_factor;
+	}
 }
 
 IC float u_diffuse2s(Fvector3& c) { return u_diffuse2s(c.x, c.y, c.z); }
diff --git a/src/Layers/xrRenderPC_R4/r4.cpp b/src/Layers/xrRenderPC_R4/r4.cpp
index 77fb925..2100ba5 100644
--- a/src/Layers/xrRenderPC_R4/r4.cpp
+++ b/src/Layers/xrRenderPC_R4/r4.cpp
@@ -81,7 +81,19 @@ ShaderElement* CRender::rimp_select_sh_static(dxRender_Visual* pVisual, float cd
 	int id = SE_R2_SHADOW;
 	if (CRender::PHASE_NORMAL == RImplementation.phase)
 	{
-		id = ((_sqrt(cdist_sq) - pVisual->vis.sphere.R) < r_dtex_range) ? SE_R2_NORMAL_HQ : SE_R2_NORMAL_LQ;
+		if (pVisual->shader->E[0]->flags.isLandscape)
+		{
+			float sec_dist = _sqrt(cdist_sq) - pVisual->vis.sphere.R;
+			id = (sec_dist < ps_ssfx_terrain_quality.x * 10) ? SE_R2_NORMAL_HQ : SE_R2_NORMAL_LQ;
+			
+			// Very low shader variation
+			if (sec_dist > 240)
+				id = 3;
+		}
+		else
+		{
+			id = ((_sqrt(cdist_sq) - pVisual->vis.sphere.R) < r_dtex_range) ? SE_R2_NORMAL_HQ : SE_R2_NORMAL_LQ;
+		}
 	}
 	return pVisual->shader->E[id]._get();
 }
@@ -456,6 +468,33 @@ void CRender::create()
 		}
 	}
 
+	// Check if SSS shaders exist
+	string_path fn;
+	o.ssfx_core = FS.exist(fn, "$game_shaders$", "r3\\screenspace_common", ".h") ? 1 : 0;
+	o.ssfx_rain = FS.exist(fn, "$game_shaders$", "r3\\effects_rain_splash", ".ps") ? 1 : 0;
+	o.ssfx_blood = FS.exist(fn, "$game_shaders$", "r3\\effects_wallmark_blood", ".ps") ? 1 : 0;
+	o.ssfx_branches = FS.exist(fn, "$game_shaders$", "r3\\deffer_tree_branch_bump-hq", ".vs") ? 1 : 0;
+	o.ssfx_hud_raindrops = FS.exist(fn, "$game_shaders$", "r3\\deffer_base_hud_bump", ".ps") ? 1 : 0;
+	o.ssfx_ssr = FS.exist(fn, "$game_shaders$", "r3\\ssfx_ssr", ".ps") ? 1 : 0;
+	o.ssfx_terrain = FS.exist(fn, "$game_shaders$", "r3\\deffer_terrain_high_flat_d", ".ps") ? 1 : 0;
+	o.ssfx_volumetric = FS.exist(fn, "$game_shaders$", "r3\\ssfx_volumetric_blur", ".ps") ? 1 : 0;
+	o.ssfx_water = FS.exist(fn, "$game_shaders$", "r3\\ssfx_water", ".ps") ? 1 : 0;
+	o.ssfx_ao = FS.exist(fn, "$game_shaders$", "r3\\ssfx_ao", ".ps") ? 1 : 0;
+	o.ssfx_il = FS.exist(fn, "$game_shaders$", "r3\\ssfx_il", ".ps") ? 1 : 0;
+
+	Msg("- Supports SSS UPDATE 21");
+	Msg("- SSS CORE INSTALLED %i", o.ssfx_core);
+	Msg("- SSS HUD RAINDROPS SHADER INSTALLED %i", o.ssfx_hud_raindrops);
+	Msg("- SSS RAIN SHADER INSTALLED %i", o.ssfx_rain);
+	Msg("- SSS BLOOD SHADER INSTALLED %i", o.ssfx_blood);
+	Msg("- SSS BRANCHES SHADER INSTALLED %i", o.ssfx_branches);
+	Msg("- SSS SSR SHADER INSTALLED %i", o.ssfx_ssr);
+	Msg("- SSS TERRAIN SHADER INSTALLED %i", o.ssfx_terrain);
+	Msg("- SSS VOLUMETRIC SHADER INSTALLED %i", o.ssfx_volumetric);
+	Msg("- SSS WATER SHADER INSTALLED %i", o.ssfx_water);
+	Msg("- SSS AO SHADER INSTALLED %i", o.ssfx_ao);
+	Msg("- SSS IL SHADER INSTALLED %i", o.ssfx_il);
+
 	// constants
 	CResourceManager* RM = dxRenderDeviceRender::Instance().Resources;
 	RM->RegisterConstantSetup("parallax", &binder_parallax);
@@ -614,6 +653,9 @@ void CRender::OnFrame()
 		Device.seqParallel.insert(Device.seqParallel.begin(),
 			fastdelegate::FastDelegate0<>(&HOM, &CHOM::MT_RENDER));
 	}
+
+	if (Details)
+		g_pGamePersistent->GrassBendersUpdateAnimations();
 }
 
 // Particles
@@ -1223,6 +1265,15 @@ HRESULT CRender::shader_compile(
 	char c_ssao [32];
 	char c_sun_quality [32];
 	char c_smaa_quality [32];
+	
+	// SSS preprocessor stuff
+	char c_ssfx_il[32];
+	char c_ssfx_ao[32];
+	char c_ssfx_water[32];
+	char c_ssfx_water_parallax[32];
+	char c_ssr_quality[32];
+	char c_rain_quality[32];
+	char c_inter_grass[32];
 
 	char sh_name[MAX_PATH] = "";
 
@@ -1680,6 +1731,77 @@ HRESULT CRender::shader_compile(
 	}
 	sh_name[len] = '0' + char(o.dx10_minmax_sm != 0);
 	++len;
+	
+	if (ps_ssfx_rain_1.w > 0)
+	{
+		xr_sprintf(c_rain_quality, "%d", u8(ps_ssfx_rain_1.w));
+		defines[def_it].Name = "SSFX_RAIN_QUALITY";
+		defines[def_it].Definition = c_rain_quality;
+		def_it++;
+		xr_strcat(sh_name, c_rain_quality);
+		len += xr_strlen(c_rain_quality);
+	}
+	else
+	{
+		sh_name[len] = '0';
+		++len;
+	}
+
+	if (ps_ssfx_grass_interactive.y > 0)
+	{
+		xr_sprintf(c_inter_grass, "%d", u8(ps_ssfx_grass_interactive.y));
+		defines[def_it].Name = "SSFX_INT_GRASS";
+		defines[def_it].Definition = c_inter_grass;
+		def_it++;
+		xr_strcat(sh_name, c_inter_grass);
+		len += xr_strlen(c_inter_grass);
+	}
+	else
+	{
+		sh_name[len] = '0';
+		++len;
+	}
+
+	xr_sprintf(c_ssr_quality, "%d", u8(min(max(ps_ssfx_ssr_quality, 0), 5)));
+	defines[def_it].Name = "SSFX_SSR_QUALITY";
+	defines[def_it].Definition = c_ssr_quality;
+	def_it++;
+	xr_strcat(sh_name, c_ssr_quality);
+	len += xr_strlen(c_ssr_quality);
+
+	xr_sprintf(c_ssfx_water, "%d", u8(min(max(ps_ssfx_water_quality.x, 0.0f), 4.0f)));
+	defines[def_it].Name = "SSFX_WATER_QUALITY";
+	defines[def_it].Definition = c_ssfx_water;
+	def_it++;
+	xr_strcat(sh_name, c_ssfx_water);
+	len += xr_strlen(c_ssfx_water);
+
+	xr_sprintf(c_ssfx_water_parallax, "%d", u8(min(max(ps_ssfx_water_quality.y, 0.0f), 3.0f)));
+	defines[def_it].Name = "SSFX_WATER_PARALLAX";
+	defines[def_it].Definition = c_ssfx_water_parallax;
+	def_it++;
+	xr_strcat(sh_name, c_ssfx_water_parallax);
+	len += xr_strlen(c_ssfx_water_parallax);
+
+	xr_sprintf(c_ssfx_il, "%d", u8(min(max(ps_ssfx_il_quality, 0), 64)));
+	defines[def_it].Name = "SSFX_IL_QUALITY";
+	defines[def_it].Definition = c_ssfx_il;
+	def_it++;
+	xr_strcat(sh_name, c_ssfx_il);
+	len += xr_strlen(c_ssfx_il);
+
+	xr_sprintf(c_ssfx_ao, "%d", u8(min(max(ps_ssfx_ao_quality, 2), 8)));
+	defines[def_it].Name = "SSFX_AO_QUALITY";
+	defines[def_it].Definition = c_ssfx_ao;
+	def_it++;
+	xr_strcat(sh_name, c_ssfx_ao);
+	len += xr_strlen(c_ssfx_ao);
+
+	defines[def_it].Name = "SSFX_MODEXE";
+	defines[def_it].Definition = "1";
+	def_it++;
+	sh_name[len] = '1';
+	++len;
 
 	//Be carefull!!!!! this should be at the end to correctly generate
 	//compiled shader name;
diff --git a/src/Layers/xrRenderPC_R4/r4.h b/src/Layers/xrRenderPC_R4/r4.h
index 9ae8b61..f948f95 100644
--- a/src/Layers/xrRenderPC_R4/r4.h
+++ b/src/Layers/xrRenderPC_R4/r4.h
@@ -57,6 +57,18 @@ public:
 public:
 	struct _options
 	{
+		u32 ssfx_branches : 1;
+		u32 ssfx_blood : 1;
+		u32 ssfx_rain : 1;
+		u32 ssfx_hud_raindrops : 1;
+		u32 ssfx_ssr : 1;
+		u32 ssfx_terrain : 1;
+		u32 ssfx_volumetric : 1;
+		u32 ssfx_water : 1;
+		u32 ssfx_ao : 1;
+		u32 ssfx_il : 1;
+		u32 ssfx_core : 1;
+
 		u32 bug : 1;
 
 		u32 ssao_blur_on : 1;
diff --git a/src/Layers/xrRenderPC_R4/r4_R_rain.cpp b/src/Layers/xrRenderPC_R4/r4_R_rain.cpp
index 30830e8..0e9ffa6 100644
--- a/src/Layers/xrRenderPC_R4/r4_R_rain.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_R_rain.cpp
@@ -30,7 +30,12 @@ static int facetable[6][4] = {
 void CRender::render_rain()
 {
 	//return;
-	float fRainFactor = g_pGamePersistent->Environment().CurrentEnv->rain_density;
+	float fRainFactor = 0;
+	if (ps_ssfx_gloss_method == 0)
+		fRainFactor = g_pGamePersistent->Environment().CurrentEnv->rain_density;
+	else
+		fRainFactor = g_pGamePersistent->Environment().wetness_factor;
+
 	if (fRainFactor < EPS_L) return;
 
 	PIX_EVENT(render_rain);
diff --git a/src/Layers/xrRenderPC_R4/r4_R_render.cpp b/src/Layers/xrRenderPC_R4/r4_R_render.cpp
index 46e1c03..8a8c40c 100644
--- a/src/Layers/xrRenderPC_R4/r4_R_render.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_R_render.cpp
@@ -321,6 +321,19 @@ void CRender::Render()
 	set_Recorder(NULL);
 	r_pmask(true, false); // disable priority "1"
 	Device.Statistic->RenderCALC.End();
+	
+	if (RImplementation.o.ssfx_core)
+	{
+		// HUD Masking rendering
+		FLOAT ColorRGBA[4] = { 1.0f, 0.0f, 0.0f, 1.0f };
+		HW.pContext->ClearRenderTargetView(Target->rt_ssfx_hud->pRT, ColorRGBA);
+
+		Target->u_setrt(Target->rt_ssfx_hud, NULL, NULL, HW.pBaseZB);
+		r_dsgraph_render_hud(true);
+
+		// Reset Depth
+		HW.pContext->ClearDepthStencilView(HW.pBaseZB, D3D_CLEAR_DEPTH, 1.0f, 0);
+	}
 
 	if (ps_r2_ls_flags.test(R2FLAG_TERRAIN_PREPASS))
 	{
@@ -532,12 +545,20 @@ void CRender::Render()
 		render_lights(LP_pending);
 	}
 
+	{
+		if (RImplementation.o.ssfx_volumetric)
+			Target->phase_ssfx_volumetric_blur();
+	}
+
 	// Postprocess
 	{
 		PIX_EVENT(DEFER_LIGHT_COMBINE);
 		Target->phase_combine();
 	}
 
+	if (Details)
+		Details->details_clear();
+
 	VERIFY(0==mapDistort.size());
 }
 
@@ -558,7 +579,7 @@ void CRender::render_forward()
 		r_dsgraph_render_graph(1); // normal level, secondary priority
 		PortalTraverser.fade_render(); // faded-portals
 		r_dsgraph_render_sorted(); // strict-sorted geoms
-		g_pGamePersistent->Environment().RenderLast(); // rain/thunder-bolts
+		//g_pGamePersistent->Environment().RenderLast(); // rain/thunder-bolts
 	}
 
 	RImplementation.o.distortion = FALSE; // disable distorion
diff --git a/src/Layers/xrRenderPC_R4/r4_loader.cpp b/src/Layers/xrRenderPC_R4/r4_loader.cpp
index 9d22692..79f6551 100644
--- a/src/Layers/xrRenderPC_R4/r4_loader.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_loader.cpp
@@ -113,6 +113,7 @@ void CRender::level_Load(IReader* fs)
 	lstLODs.clear();
 	lstLODgroups.clear();
 	mapLOD.clear();
+	mapWater.clear();
 
 	// signal loaded
 	b_loaded = TRUE;
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
index 4280e5f..67fb801 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
@@ -29,6 +29,15 @@
 
 #include <D3DX10Tex.h>
 
+D3D_VIEWPORT custom_viewport[1] = { 0, 0, 0, 0, 0.f, 1.f };
+
+void CRenderTarget::set_viewport_size(ID3DDeviceContext * dev, float w, float h)
+{
+	custom_viewport[0].Width = w;
+	custom_viewport[0].Height = h;
+	dev->RSSetViewports(1, custom_viewport);
+}
+
 void CRenderTarget::u_setrt(const ref_rt& _1, const ref_rt& _2, const ref_rt& _3, ID3DDepthStencilView* zb)
 {
 	VERIFY(_1||zb);
@@ -353,6 +362,11 @@ CRenderTarget::CRenderTarget()
 	b_lut = xr_new<CBlender_lut>();
 	b_smaa = xr_new<CBlender_smaa>();
 
+	// Screen Space Shaders Stuff
+	b_ssfx_ssr = xr_new<CBlender_ssfx_ssr>(); // SSR
+	b_ssfx_volumetric_blur = xr_new<CBlender_ssfx_volumetric_blur>(); // Volumetric Blur
+	b_ssfx_ao = xr_new<CBlender_ssfx_ao>(); // AO
+
 	// HDAO
 	b_hdao_cs = xr_new<CBlender_CS_HDAO>();
 	if (RImplementation.o.dx10_msaa)
@@ -457,7 +471,24 @@ CRenderTarget::CRenderTarget()
 		rt_blur_8.create(r2_RT_blur_8, u32(w/8), u32(h/8), D3DFMT_A8R8G8B8);	
 		
 		rt_pp_bloom.create(r2_RT_pp_bloom, w, h, D3DFMT_A8R8G8B8);
-			
+		
+		// Screen Space Shaders Stuff
+		rt_ssfx.create(r2_RT_ssfx, w, h, D3DFMT_A8R8G8B8); // Temp RT
+		rt_ssfx_temp.create(r2_RT_ssfx_temp, w, h, D3DFMT_A8R8G8B8); // Temp RT
+		rt_ssfx_temp2.create(r2_RT_ssfx_temp2, w, h, D3DFMT_A8R8G8B8); // Temp RT
+		rt_ssfx_temp3.create(r2_RT_ssfx_temp3, w, h, D3DFMT_A8R8G8B8); // Temp RT
+
+		rt_ssfx_accum.create(r2_RT_ssfx_accum, w, h, D3DFMT_A16B16G16R16F, SampleCount); // Volumetric Acc
+		rt_ssfx_ssr.create(r2_RT_ssfx_ssr, w, h, D3DFMT_A8R8G8B8); // SSR Acc
+		rt_ssfx_water.create(r2_RT_ssfx_water, w, h, D3DFMT_A8R8G8B8); // Water Acc
+		rt_ssfx_ao.create(r2_RT_ssfx_ao, w, h, D3DFMT_A8R8G8B8); // AO Acc
+		rt_ssfx_il.create(r2_RT_ssfx_il, w, h, D3DFMT_A8R8G8B8); // IL Acc
+
+		rt_ssfx_water_waves.create(r2_RT_ssfx_water_waves, 512, 512, D3DFMT_A8R8G8B8); // Water Waves
+
+		rt_ssfx_prevPos.create(r2_RT_ssfx_prevPos, w, h, D3DFMT_A16B16G16R16F, SampleCount);
+
+		rt_ssfx_hud.create(r2_RT_ssfx_hud, w, h, D3DFMT_A16B16G16R16F); // HUD mask & Velocity buffer
 		
 		if (RImplementation.o.dx10_msaa)
 		{
@@ -483,6 +514,22 @@ CRenderTarget::CRenderTarget()
 	// OCCLUSION
 	s_occq.create(b_occq, "r2\\occq");
 
+	// Screen Space Shaders Stuff
+	s_ssfx_ssr.create(b_ssfx_ssr, "r2\\ssfx_ssr"); // SSR
+	s_ssfx_volumetric_blur.create(b_ssfx_volumetric_blur, "r2\\ssfx_volumetric_blur"); // Volumetric Blur
+	
+	s_ssfx_water_ssr.create("ssfx_water_ssr"); // Water SSR
+	s_ssfx_water.create("ssfx_water"); // Water
+
+	s_ssfx_ao.create(b_ssfx_ao, "ssfx_ao"); // SSR
+
+	string32 cskin_buffer;
+	for (int skin_num = 0; skin_num < 5; skin_num++)
+	{
+		sprintf(cskin_buffer, "ssfx_hud_skin%i", skin_num);
+		s_ssfx_hud[skin_num].create(cskin_buffer);
+	}
+
 	// DIRECT (spot)
 	D3DFORMAT depth_format = (D3DFORMAT)RImplementation.o.HW_smap_FORMAT;
 
@@ -1159,6 +1206,11 @@ CRenderTarget::~CRenderTarget()
 	xr_delete(b_lut);	
 	xr_delete(b_smaa);
 
+	// [ SSS Stuff ]
+	xr_delete(b_ssfx_ssr); // SSR Phase
+	xr_delete(b_ssfx_volumetric_blur); // Volumetric Phase
+	xr_delete(b_ssfx_ao); // AO Phase
+
 	if (RImplementation.o.dx10_msaa)
 	{
 		int bound = RImplementation.o.dx10_msaa_samples;
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget.h b/src/Layers/xrRenderPC_R4/r4_rendertarget.h
index 37da92e..8afbc39 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget.h
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget.h
@@ -64,6 +64,11 @@ public:
 	IBlender* b_hdao_cs;
 	IBlender* b_hdao_msaa_cs;
 
+	// [SSS Stuff]
+	IBlender* b_ssfx_ssr;
+	IBlender* b_ssfx_volumetric_blur;
+	IBlender* b_ssfx_ao;
+
 #ifdef DEBUG
 	struct		dbg_line_t		{
 		Fvector	P0,P1;
@@ -134,6 +139,32 @@ public:
 	//	TODO: DX10: CHeck if we need old-style SMAP
 	//	IDirect3DSurface9*			rt_smap_ZB;		//
 
+	// Screen Space Shaders Stuff
+	ref_rt rt_ssfx;
+	ref_rt rt_ssfx_temp;
+	ref_rt rt_ssfx_temp2;
+	ref_rt rt_ssfx_temp3;
+
+	ref_rt rt_ssfx_accum;
+	ref_rt rt_ssfx_hud;
+	ref_rt rt_ssfx_ssr;
+	ref_rt rt_ssfx_water;
+	ref_rt rt_ssfx_water_waves;
+	ref_rt rt_ssfx_ao;
+	ref_rt rt_ssfx_il;
+
+	ref_rt rt_ssfx_prevPos;
+
+	ref_shader s_ssfx_water;
+	ref_shader s_ssfx_water_ssr;
+	ref_shader s_ssfx_ao;
+	ref_shader s_ssfx_hud[5];
+
+	Fmatrix Matrix_previous, Matrix_current;
+	Fmatrix Matrix_HUD_previous, Matrix_HUD_current;
+	Fvector3 Position_previous;
+	bool RVelocity;
+
 	//	Igor: for async screenshots
 	ID3DTexture2D* t_ss_async; //32bit		(r,g,b,a) is situated in the system memory
 
@@ -194,6 +225,10 @@ private:
 	ref_shader s_accum_reflected_msaa[8];
 	ref_shader s_accum_volume_msaa[8];
 
+	// Screen Space Shaders Stuff
+	ref_shader s_ssfx_ssr;
+	ref_shader s_ssfx_volumetric_blur;
+
 	ref_geom g_accum_point;
 	ref_geom g_accum_spot;
 	ref_geom g_accum_omnipart;
@@ -319,6 +354,15 @@ public:
 	void phase_vol_accumulator();
 	void shadow_direct(light* L, u32 dls_phase);
 
+	// SSS Stuff
+	void phase_ssfx_ssr(); // SSR Phase
+	void phase_ssfx_volumetric_blur(); // Volumetric Blur
+	void phase_ssfx_water_blur(); // Water Blur
+	void phase_ssfx_water_waves(); // Water Waves
+	void phase_ssfx_ao(); // AO
+	void phase_ssfx_il(); // IL
+	void set_viewport_size(ID3DDeviceContext* dev, float w, float h);
+
 	//	Generates min/max sm
 	void create_minmax_SM();
 
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget_accum_direct.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget_accum_direct.cpp
index d0e06c9..eb39282 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget_accum_direct.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget_accum_direct.cpp
@@ -205,10 +205,11 @@ void CRenderTarget::accum_direct(u32 sub_phase)
 			Fmatrix m_xform;
 			Fvector direction = fuckingsun->direction;
 			float w_dir = g_pGamePersistent->Environment().CurrentEnv->wind_direction;
-			//float	w_speed				= g_pGamePersistent->Environment().CurrentEnv->wind_velocity	;
+			float w_speed = g_pGamePersistent->Environment().CurrentEnv->wind_velocity * 0.001f;
+			clamp(w_speed, 0.1f, 1.0f);
 			Fvector normal;
-			normal.setHP(w_dir, 0);
-			w_shift += 0.003f * Device.fTimeDelta;
+			normal.setHP(-w_dir, 0);
+			w_shift -= 0.005f * w_speed * Device.fTimeDelta;
 			Fvector position;
 			position.set(0, 0, 0);
 			m_xform.build_camera_dir(position, direction, normal);
@@ -519,10 +520,11 @@ void CRenderTarget::accum_direct_cascade(u32 sub_phase, Fmatrix& xform, Fmatrix&
 			Fmatrix m_xform;
 			Fvector direction = fuckingsun->direction;
 			float w_dir = g_pGamePersistent->Environment().CurrentEnv->wind_direction;
-			//float	w_speed				= g_pGamePersistent->Environment().CurrentEnv->wind_velocity	;
+			float w_speed = g_pGamePersistent->Environment().CurrentEnv->wind_velocity * 0.001f;
+			clamp(w_speed, 0.1f, 1.0f);
 			Fvector normal;
-			normal.setHP(w_dir, 0);
-			w_shift += 0.003f * Device.fTimeDelta;
+			normal.setHP(-w_dir, 0);
+			w_shift -= 0.005f * w_speed * Device.fTimeDelta;
 			Fvector position;
 			position.set(0, 0, 0);
 			m_xform.build_camera_dir(position, direction, normal);
@@ -1209,6 +1211,12 @@ void CRenderTarget::accum_direct_volumetric(u32 sub_phase, const u32 Offset, con
 
 	if ((sub_phase != SE_SUN_NEAR) && (sub_phase != SE_SUN_FAR)) return;
 
+	float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	if (RImplementation.o.ssfx_volumetric)
+		set_viewport_size(HW.pContext, w / ps_ssfx_volumetric.w, h / ps_ssfx_volumetric.w);
+
 	phase_vol_accumulator();
 
 	RCache.set_ColorWriteEnable();
@@ -1379,5 +1387,8 @@ void CRenderTarget::accum_direct_volumetric(u32 sub_phase, const u32 Offset, con
 		//	TODO: DX10: Check if DX10 has analog for NV DBT
 		// disable depth bounds
 		//		u_DBT_disable	();
+
+		if (RImplementation.o.ssfx_volumetric)
+			set_viewport_size(HW.pContext, w, h);
 	}
 }
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget_accum_spot.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget_accum_spot.cpp
index aa2d2dc..080ff61 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget_accum_spot.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget_accum_spot.cpp
@@ -129,14 +129,14 @@ void CRenderTarget::accum_spot(light* L)
 	}
 
 	// Common constants
-	Fvector L_dir, L_clr, L_pos;
+	Fvector L_clr, L_pos; // L_dir
 	float L_spec;
 	L_clr.set(L->color.r, L->color.g, L->color.b);
 	L_clr.mul(L->get_LOD());
 	L_spec = u_diffuse2s(L_clr);
 	Device.mView.transform_tiny(L_pos, L->position);
-	Device.mView.transform_dir(L_dir, L->direction);
-	L_dir.normalize();
+	//Device.mView.transform_dir(L_dir, L->direction);
+	//L_dir.normalize();
 
 	// Draw volume with projective texgen
 	{
@@ -272,8 +272,22 @@ void CRenderTarget::accum_spot(light* L)
 
 void CRenderTarget::accum_volumetric(light* L)
 {
+	// [ SSS ] Fade through distance volumetric lights.
+	if (ps_ssfx_volumetric.x > 0)
+	{
+		float Falloff = ps_ssfx_volumetric.y - std::min(std::max((L->vis.distance - 20) * 0.01f, 0.0f), 1.0f) * ps_ssfx_volumetric.y;
+		L->m_volumetric_intensity = Falloff;
+		L->flags.bVolumetric = Falloff <= 0 ? false : true;
+	}
+
 	//if (L->flags.type != IRender_Light::SPOT) return;
 	if (!L->flags.bVolumetric) return;
+	
+	/*float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	if (RImplementation.o.ssfx_volumetric)
+		set_viewport_size(HW.pContext, w / ps_ssfx_volumetric.w, h / ps_ssfx_volumetric.w);*/
 
 	phase_vol_accumulator();
 
@@ -306,10 +320,10 @@ void CRenderTarget::accum_volumetric(light* L)
 	RCache.set_CullMode(CULL_NONE); // back
 
 	// 2D texgens 
-	Fmatrix m_Texgen;
+	/*Fmatrix m_Texgen;
 	u_compute_texgen_screen(m_Texgen);
 	Fmatrix m_Texgen_J;
-	u_compute_texgen_jitter(m_Texgen_J);
+	u_compute_texgen_jitter(m_Texgen_J);*/
 
 	// Shadow xform (+texture adjustment matrix)
 	Fmatrix m_Shadow, m_Lmap;
@@ -414,24 +428,53 @@ void CRenderTarget::accum_volumetric(light* L)
 			
 		}
 	*/
-	// Common constants
-	float fQuality = L->m_volumetric_quality;
-	int iNumSlises = (int)(VOLUMETRIC_SLICES * fQuality);
-	//			min 10 surfaces
-	iNumSlises = _max(10, iNumSlises);
-	//	Adjust slice intensity
-	fQuality = ((float)iNumSlises) / VOLUMETRIC_SLICES;
-	Fvector L_dir, L_clr, L_pos;
+	// Common vars
+	float fQuality = 0;
+	int iNumSlices = 0;
+
+	// Color and intensity vars
+	Fvector L_clr, L_pos;
 	float L_spec;
+	float IntensityMod = 1.0f;
 	L_clr.set(L->color.r, L->color.g, L->color.b);
-	L_clr.mul(L->m_volumetric_intensity);
 	L_clr.mul(L->m_volumetric_distance);
-	L_clr.mul(1 / fQuality);
-	L_clr.mul(L->get_LOD());
+
+	if (ps_ssfx_volumetric.x <= 0)
+	{
+		// Vanilla Method
+		fQuality = L->m_volumetric_quality;
+		iNumSlices = (int)(VOLUMETRIC_SLICES * fQuality);
+		//			min 10 surfaces
+		iNumSlices = _max(10, iNumSlices);
+
+		// Set Intensity
+		fQuality = ((float)iNumSlices) / VOLUMETRIC_SLICES;
+		L_clr.mul(L->m_volumetric_intensity);
+		L_clr.mul(1 / fQuality);
+		L_clr.mul(L->get_LOD());
+	}
+	else
+	{
+		// SSS Method
+		fQuality = ps_ssfx_volumetric.z;
+		iNumSlices = (int)(24 * fQuality);
+
+		// Intensity mod to OMNIPART && HUD
+		if (L->flags.type == IRender_Light::OMNIPART || L->flags.bHudMode)
+			IntensityMod = 0.2f;
+
+		// Set Intensity
+		L_clr.mul(L->m_volumetric_intensity * IntensityMod);
+		L_clr.mul(1.0f / fQuality);
+		L_clr.mul(L->get_LOD());
+		fQuality = ((float)iNumSlices) / 120; // Max setting ( 24 * 5 )
+	}
+
 	L_spec = u_diffuse2s(L_clr);
 	Device.mView.transform_tiny(L_pos, L->position);
-	Device.mView.transform_dir(L_dir, L->direction);
-	L_dir.normalize();
+	//Device.mView.transform_dir(L_dir, L->direction);
+	//L_dir.normalize();
+
 
 	// Draw volume with projective texgen
 	{
@@ -488,8 +531,8 @@ void CRenderTarget::accum_volumetric(light* L)
 		float att_factor = 1.f / (att_R * att_R);
 		RCache.set_c("Ldynamic_pos", L_pos.x, L_pos.y, L_pos.z, att_factor);
 		RCache.set_c("Ldynamic_color", L_clr.x, L_clr.y, L_clr.z, L_spec);
-		RCache.set_c("m_texgen", m_Texgen);
-		RCache.set_c("m_texgen_J", m_Texgen_J);
+		//RCache.set_c("m_texgen", m_Texgen);
+		//RCache.set_c("m_texgen_J", m_Texgen_J);
 		RCache.set_c("m_shadow", m_Shadow);
 		RCache.set_ca("m_lmap", 0, m_Lmap._11, m_Lmap._21, m_Lmap._31, m_Lmap._41);
 		RCache.set_ca("m_lmap", 1, m_Lmap._12, m_Lmap._22, m_Lmap._32, m_Lmap._42);
@@ -566,7 +609,7 @@ void CRenderTarget::accum_volumetric(light* L)
 
 		RCache.set_Geometry(g_accum_volumetric);
 		//	Igor: no need to do it per sub-sample. Plain AA will go just fine.
-		RCache.Render(D3DPT_TRIANGLELIST, 0, 0,VOLUMETRIC_SLICES * 4, 0,VOLUMETRIC_SLICES * 2);
+		RCache.Render(D3DPT_TRIANGLELIST, 0, 0, iNumSlices * 4, 0, iNumSlices * 2);
 
 		/*
 		if( !RImplementation.o.dx10_msaa )
@@ -624,4 +667,8 @@ void CRenderTarget::accum_volumetric(light* L)
 	*/
 	//CHK_DX		(HW.pDevice->SetRenderState(D3DRS_SCISSORTESTENABLE,FALSE));
 	RCache.set_Scissor(0);
+
+	/*if (RImplementation.o.ssfx_volumetric)
+		set_viewport_size(HW.pContext, w, h);*/
+
 }
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget_draw_rain.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget_draw_rain.cpp
index 47d6c8d..b413abb 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget_draw_rain.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget_draw_rain.cpp
@@ -59,7 +59,10 @@ void CRenderTarget::draw_rain(light& RainSetup)
 	}
 
 	// recalculate d_Z, to perform depth-clipping
-	const float fRainFar = ps_r3_dyn_wet_surf_far;
+	float fRainFar = 250;
+
+	if (ps_ssfx_gloss_method == 0)
+		fRainFar = ps_r3_dyn_wet_surf_far;
 
 	Fvector center_pt;
 	center_pt.mad(Device.vCameraPosition, Device.vCameraDirection, fRainFar);
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_accumulator.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_accumulator.cpp
index 4a4ed70..c3c1a93 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_accumulator.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_accumulator.cpp
@@ -68,9 +68,9 @@ void CRenderTarget::phase_vol_accumulator()
 	{
 		m_bHasActiveVolumetric = true;
 		if (!RImplementation.o.dx10_msaa)
-			u_setrt(rt_Generic_2, NULL,NULL, HW.pBaseZB);
+			u_setrt(rt_Generic_2, NULL,NULL, RImplementation.o.ssfx_volumetric ? NULL : HW.pBaseZB);
 		else
-			u_setrt(rt_Generic_2, NULL,NULL, RImplementation.Target->rt_MSAADepth->pZRT);
+			u_setrt(rt_Generic_2, NULL,NULL, RImplementation.o.ssfx_volumetric ? NULL : HW.pBaseZB);
 		//u32		clr4clearVol				= color_rgba(0,0,0,0);	// 0x00
 		//CHK_DX	(HW.pDevice->Clear			( 0L, NULL, D3DCLEAR_TARGET, clr4clearVol, 1.0f, 0L));
 		FLOAT ColorRGBA[4] = {0.0f, 0.0f, 0.0f, 0.0f};
@@ -79,9 +79,9 @@ void CRenderTarget::phase_vol_accumulator()
 	else
 	{
 		if (!RImplementation.o.dx10_msaa)
-			u_setrt(rt_Generic_2, NULL,NULL, HW.pBaseZB);
+			u_setrt(rt_Generic_2, NULL,NULL, RImplementation.o.ssfx_volumetric ? NULL : HW.pBaseZB);
 		else
-			u_setrt(rt_Generic_2, NULL,NULL, RImplementation.Target->rt_MSAADepth->pZRT);
+			u_setrt(rt_Generic_2, NULL,NULL, RImplementation.o.ssfx_volumetric ? NULL : HW.pBaseZB);
 	}
 
 	RCache.set_Stencil(FALSE);
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
index 875ae48..791a802 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
@@ -39,6 +39,8 @@ float hclip(float v, float dim) { return 2.f * v / dim - 1.f; }
 void CRenderTarget::phase_combine()
 {
 	PIX_EVENT(phase_combine);
+	
+	bool ssfx_PrevPos_Requiered = false;
 
 	//	TODO: DX10: Remove half poxel offset
 	bool _menu_pp = g_pGamePersistent ? g_pGamePersistent->OnRenderPPUI_query() : false;
@@ -76,6 +78,50 @@ void CRenderTarget::phase_combine()
 			phase_ssao();
 	}
 
+	// Save previus and current matrices
+	Fvector2 m_blur_scale;
+	{
+		static Fmatrix m_saved_viewproj;
+
+		if (!Device.m_SecondViewport.IsSVPFrame())
+		{
+			static Fvector3 saved_position;
+			Position_previous.set(saved_position);
+			saved_position.set(Device.vCameraPosition);
+
+			Fmatrix m_invview;
+			m_invview.invert(Device.mView);
+			Matrix_previous.mul(m_saved_viewproj, m_invview);
+			Matrix_current.set(Device.mProject);
+			m_saved_viewproj.set(Device.mFullTransform);
+		}
+		float scale = ps_r2_mblur / 2.f;
+		m_blur_scale.set(scale, -scale).div(12.f);
+	}
+
+	{
+		// Disable when rendering SecondViewport
+		if (!Device.m_SecondViewport.IsSVPFrame())
+		{
+			// Clear RT
+			FLOAT ColorRGBA[4] = { 0.0f, 0.0f, 0.0f, 1.0f };
+			HW.pContext->ClearRenderTargetView(rt_ssfx_temp->pRT, ColorRGBA);
+			HW.pContext->ClearRenderTargetView(rt_ssfx_temp2->pRT, ColorRGBA);
+
+			if (RImplementation.o.ssfx_ao && ps_ssfx_ao.y > 0)
+			{
+				ssfx_PrevPos_Requiered = true;
+				phase_ssfx_ao(); // [SSFX] - New AO Phase
+			}
+
+			if (RImplementation.o.ssfx_il && ps_ssfx_il.y > 0)
+			{
+				ssfx_PrevPos_Requiered = true;
+				phase_ssfx_il(); // [SSFX] - New IL Phase
+			}
+		}
+	}
+
 	FLOAT ColorRGBA[4] = {0.0f, 0.0f, 0.0f, 0.0f};
 	// low/hi RTs
 	if (!RImplementation.o.dx10_msaa)
@@ -124,7 +170,7 @@ void CRenderTarget::phase_combine()
 	//}
 
 	// calc m-blur matrices
-	Fmatrix m_previous, m_current;
+	/*Fmatrix m_previous, m_current;
 	Fvector2 m_blur_scale;
 	{
 		static Fmatrix m_saved_viewproj;
@@ -137,7 +183,7 @@ void CRenderTarget::phase_combine()
 		m_saved_viewproj.set(Device.mFullTransform);
 		float scale = ps_r2_mblur / 2.f;
 		m_blur_scale.set(scale, -scale).div(12.f);
-	}
+	}*/
 
 	// Draw full-screen quad textured with our scene image
 	if (!_menu_pp)
@@ -287,6 +333,60 @@ void CRenderTarget::phase_combine()
     else
         HW.pContext->CopyResource(rt_Generic_temp->pTexture->surface_get(), rt_Generic_0_r->pTexture->surface_get());
 
+	if (RImplementation.o.ssfx_ssr && !Device.m_SecondViewport.IsSVPFrame())
+	{
+		ssfx_PrevPos_Requiered = true;
+		phase_ssfx_ssr(); // [SSFX] - New SSR Phase
+	}
+
+	// [SSFX] - Water SSR rendering
+	if (RImplementation.o.ssfx_water && !Device.m_SecondViewport.IsSVPFrame())
+	{
+		FLOAT ColorRGBA[4] = { 0.0f, 0.0f, 0.0f, 1.0f };
+		HW.pContext->ClearRenderTargetView(rt_ssfx_temp->pRT, ColorRGBA);
+		HW.pContext->ClearRenderTargetView(rt_ssfx_temp2->pRT, ColorRGBA);
+
+		if (!RImplementation.o.dx10_msaa)
+			u_setrt(rt_ssfx_temp, 0, 0, 0);
+		else
+			u_setrt(rt_ssfx_temp, 0, 0, 0);
+
+		float w = float(Device.dwWidth);
+		float h = float(Device.dwHeight);
+
+		// Render Scale
+		set_viewport_size(HW.pContext, w / ps_ssfx_water.x, h / ps_ssfx_water.x);
+
+		// Render Water SSR
+		RCache.set_xform_world(Fidentity);
+		RImplementation.r_dsgraph_render_water_ssr();
+
+		// Restore Viewport
+		set_viewport_size(HW.pContext, w, h);
+
+		// Save Frame
+		HW.pContext->CopyResource(rt_ssfx_water->pTexture->surface_get(), rt_ssfx_temp->pTexture->surface_get());
+
+		// Water SSR Blur
+		phase_ssfx_water_blur();
+
+		// Water waves
+		phase_ssfx_water_waves();
+	}
+
+	if (!RImplementation.o.dx10_msaa)
+		u_setrt(rt_Generic_0, 0, 0, HW.pBaseZB);
+	else
+		u_setrt(rt_Generic_0_r, 0, 0, rt_MSAADepth->pZRT);
+
+	// Final water rendering ( All the code above can be omitted if the Water module isn't installed )
+	RCache.set_xform_world(Fidentity);
+	RImplementation.r_dsgraph_render_water();
+	g_pGamePersistent->Environment().RenderLast(); // rain/thunder-bolts
+
+	if (ssfx_PrevPos_Requiered)
+		HW.pContext->CopyResource(rt_ssfx_prevPos->pTexture->surface_get(), rt_Position->pTexture->surface_get());
+
 	// Forward rendering
 	{
 		PIX_EVENT(Forward_rendering);
@@ -375,7 +475,8 @@ void CRenderTarget::phase_combine()
 	}
 	
 	//Compute blur textures
-	phase_blur();
+	if (!Device.m_SecondViewport.IsSVPFrame()) // Temp fix for blur buffer and SVP
+		phase_blur();
 
 	//Compute bloom (new)
 	phase_pp_bloom();
@@ -510,8 +611,8 @@ void CRenderTarget::phase_combine()
 		RCache.set_c("e_barrier", ps_r2_aa_barier.x, ps_r2_aa_barier.y, ps_r2_aa_barier.z, 0);
 		RCache.set_c("e_weights", ps_r2_aa_weight.x, ps_r2_aa_weight.y, ps_r2_aa_weight.z, 0);
 		RCache.set_c("e_kernel", ps_r2_aa_kernel, ps_r2_aa_kernel, ps_r2_aa_kernel, 0);
-		RCache.set_c("m_current", m_current);
-		RCache.set_c("m_previous", m_previous);
+		RCache.set_c("m_current", Matrix_current);
+		RCache.set_c("m_previous", Matrix_previous);
 		RCache.set_c("m_blur", m_blur_scale.x, m_blur_scale.y, 0, 0);
 		/////lvutner		
 		RCache.set_c("mask_control", ps_r2_mask_control.x, ps_r2_mask_control.y, ps_r2_mask_control.z, ps_r2_mask_control.w);
@@ -694,19 +795,15 @@ void CRenderTarget::phase_combine_volumetric()
 	RCache.set_ColorWriteEnable(D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE);
 	{
 		// Fill VB
-		float scale_X = float(Device.dwWidth) / float(TEX_jitter);
-		float scale_Y = float(Device.dwHeight) / float(TEX_jitter);
+		//float scale_X = float(Device.dwWidth) / float(TEX_jitter);
+		//float scale_Y = float(Device.dwHeight) / float(TEX_jitter);
 
 		// Fill vertex buffer
 		FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
-		pv->set(-1, 1, 0, 1, 0, 0, scale_Y);
-		pv++;
-		pv->set(-1, -1, 0, 0, 0, 0, 0);
-		pv++;
-		pv->set(1, 1, 1, 1, 0, scale_X, scale_Y);
-		pv++;
-		pv->set(1, -1, 1, 0, 0, scale_X, 0);
-		pv++;
+		pv->set(-1, 1, 0, 1, 0, 0, 1); pv++;
+		pv->set(-1, -1, 0, 0, 0, 0, 0); pv++;
+		pv->set(1, 1, 1, 1, 0, 1, 1); pv++;
+		pv->set(1, -1, 1, 0, 0, 1, 0); pv++;
 		RCache.Vertex.Unlock(4, g_combine->vb_stride);
 
 		// Draw
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_ssao.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_ssao.cpp
index 6315c28..2db8c84 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_ssao.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_ssao.cpp
@@ -167,3 +167,286 @@ void CRenderTarget::phase_downsamp()
 	if (RImplementation.o.ssao_half_data)
 		set_viewport(HW.pContext, float(Device.dwWidth), float(Device.dwHeight));
 }
+
+void CRenderTarget::phase_ssfx_ao()
+{
+
+	//Constants
+	u32 Offset = 0;
+	u32 C = color_rgba(0, 0, 0, 255);
+
+	float d_Z = EPS_S;
+	float d_W = 1.0f;
+	float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	float ScaleFactor = std::min(std::max(ps_ssfx_ao.x, 1.0f), 8.0f);
+
+	Fvector2 p0, p1;
+	p0.set(0.0f, 0.0f);
+	p1.set(1.0f / ScaleFactor, 1.0f / ScaleFactor);
+
+	// Fill VB
+	float scale_X = w / ScaleFactor;
+	float scale_Y = h / ScaleFactor;
+
+	// AO ///////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_temp, 0, 0, 0);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	set_viewport_size(HW.pContext, scale_X, scale_Y);
+
+	//Fill vertex buffer
+	FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	//Set pass
+	RCache.set_Element(s_ssfx_ao->E[0]);
+	RCache.set_c("ao_setup", ps_ssfx_ao);
+
+	RCache.set_c("m_current", Matrix_current);
+	RCache.set_c("m_previous", Matrix_previous);
+
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+	// Save AO frame
+	HW.pContext->CopyResource(rt_ssfx_ao->pTexture->surface_get(), rt_ssfx_temp->pTexture->surface_get());
+
+	//scale_X = w / (ScaleFactor * 2.0f);
+	//scale_Y = h / (ScaleFactor * 2.0f);
+
+	p1.set(1.0f, 1.0f);
+	set_viewport_size(HW.pContext, w, h);
+
+	// BLUR PHASE 1 //////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_temp3, 0, 0, 0);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_ao->E[1]);
+	RCache.set_c("blur_setup", ps_ssfx_ao.x, 0.25f, scale_X, scale_Y);
+	RCache.set_c("ao_setup", ps_ssfx_ao);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+
+	// BLUR PHASE 2 //////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_temp, 0, 0, 0);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_ao->E[2]);
+	RCache.set_c("blur_setup", 1, 0.5f, scale_X, scale_Y);
+	RCache.set_c("ao_setup", ps_ssfx_ao);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+
+	// BLUR PHASE 3 //////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_temp3, 0, 0, 0);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_ao->E[1]);
+	RCache.set_c("blur_setup", 1, 0.75f, scale_X, scale_Y);
+	RCache.set_c("ao_setup", ps_ssfx_ao);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+	// BLUR PHASE 4 //////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_temp, 0, 0, 0);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_ao->E[2]);
+	RCache.set_c("blur_setup", 1, 1.0f, scale_X, scale_Y);
+	RCache.set_c("ao_setup", ps_ssfx_ao);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+	set_viewport_size(HW.pContext, w, h);
+}
+
+
+void CRenderTarget::phase_ssfx_il()
+{
+
+	//Constants
+	u32 Offset = 0;
+	u32 C = color_rgba(0, 0, 0, 255);
+
+	float d_Z = EPS_S;
+	float d_W = 1.0f;
+	float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	float ScaleFactor = std::min(std::max(ps_ssfx_il.x, 1.0f), 8.0f);
+
+	Fvector2 p0, p1;
+	p0.set(0.0f, 0.0f);
+	p1.set(1.0f / ScaleFactor, 1.0f / ScaleFactor);
+
+	// Fill VB
+	float scale_X = w / ScaleFactor;
+	float scale_Y = h / ScaleFactor;
+
+	// AO ///////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_temp2, 0, 0, 0);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	set_viewport_size(HW.pContext, scale_X, scale_Y);
+
+	//Fill vertex buffer
+	FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	//Set pass
+	RCache.set_Element(s_ssfx_ao->E[3]);
+	RCache.set_c("ao_setup", ps_ssfx_il);
+	RCache.set_c("m_current", Matrix_current);
+	RCache.set_c("m_previous", Matrix_previous);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+
+	// Save AO frame
+	HW.pContext->CopyResource(rt_ssfx_il->pTexture->surface_get(), rt_ssfx_temp2->pTexture->surface_get());
+
+	//scale_X = w / ScaleFactor;
+	//scale_Y = h / ScaleFactor;
+
+	//p1.set(1.0f / ScaleFactor, 1.0f / ScaleFactor);
+	//set_viewport_size(HW.pContext, scale_X, scale_Y);
+
+	// BLUR PHASE 1 //////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_temp3, 0, 0, 0);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_ao->E[4]);
+	RCache.set_c("blur_setup", 1, 0.25f, scale_X, scale_Y);
+	RCache.set_c("ao_setup", ps_ssfx_il);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+
+	// BLUR PHASE 2 //////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_temp2, 0, 0, 0);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_ao->E[5]);
+	RCache.set_c("blur_setup", 1, 0.5f, scale_X, scale_Y);
+	RCache.set_c("ao_setup", ps_ssfx_il);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+
+	// BLUR PHASE 3 //////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_temp3, 0, 0, 0);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_ao->E[4]);
+	RCache.set_c("blur_setup", 1, 0.75f, scale_X, scale_Y);
+	RCache.set_c("ao_setup", ps_ssfx_il);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+	// BLUR PHASE 4 //////////////////////////////////////////////////////////
+	u_setrt(rt_ssfx_temp2, 0, 0, 0);
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	// Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, h, d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(w, h, d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(w, 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	// Draw COLOR
+	RCache.set_Element(s_ssfx_ao->E[5]);
+	RCache.set_c("blur_setup", 1, 1.0f, scale_X, scale_Y);
+	RCache.set_c("ao_setup", ps_ssfx_il);
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+
+	set_viewport_size(HW.pContext, w, h);
+}
\ No newline at end of file
diff --git a/src/xrCore/xr_resource.h b/src/xrCore/xr_resource.h
index c383703..f35fd52 100644
--- a/src/xrCore/xr_resource.h
+++ b/src/xrCore/xr_resource.h
@@ -23,6 +23,8 @@ public:
 
 public:
 	u32 dwFlags;
+	int skinning;
+	bool hud_disabled;
 
 	xr_resource_flagged() : dwFlags(0)
 	{
diff --git a/src/xrEngine/Environment.cpp b/src/xrEngine/Environment.cpp
index bd4a486..e931cc3 100644
--- a/src/xrEngine/Environment.cpp
+++ b/src/xrEngine/Environment.cpp
@@ -43,6 +43,8 @@ static const float MAX_NOISE_FREQ = 0.03f;
 
 const float MAX_DIST_FACTOR = 0.95f;
 
+extern Fvector4 ps_ssfx_wind_trees;
+
 //////////////////////////////////////////////////////////////////////////
 // environment
 CEnvironment::CEnvironment() :
@@ -82,6 +84,8 @@ CEnvironment::CEnvironment() :
 	wind_blast_strength_start_value = 0.f;
 	wind_blast_strength_stop_value = 0.f;
 
+	wind_anim = { 0.0f, 0.0f, 0.0f, 0.0f };
+
 	// fill clouds hemi verts & faces
 	const Fvector* verts;
 	CloudsVerts.resize(xrHemisphereVertices(2, verts));
@@ -560,6 +564,20 @@ void CEnvironment::OnFrame()
 	if (!g_pGameLevel) return;
 #endif
 
+	// Min wind velocity. [ ps_ssfx_wind_trees.w 0 ~ 1 ]
+	float WindVel = _max(CurrentEnv->wind_velocity, ps_ssfx_wind_trees.w * 1000);
+
+	// Limit min at 200 to avoid slow-mo at extremly low speed.
+	WindVel = _max(WindVel, 200) * 0.001f;
+
+	float WindDir = -CurrentEnv->wind_direction + PI_DIV_2;
+	Fvector2 WDir = { _cos(WindDir), _sin(WindDir) };
+	
+	wind_anim.x += WindVel * WDir.x * Device.fTimeDelta;
+	wind_anim.y += WindVel * WDir.y * Device.fTimeDelta;
+	wind_anim.z += clampr(WindVel * 1.33f, 0.0f, 1.0f) * Device.fTimeDelta;
+	wind_anim.w += 1.0f * Device.fTimeDelta;
+
 	// if (pInput->iGetAsyncKeyState(DIK_O)) SetWeatherFX("surge_day");
 	float current_weight;
 	lerp(current_weight);
diff --git a/src/xrEngine/Environment.h b/src/xrEngine/Environment.h
index 2b8cd53..ec1c769 100644
--- a/src/xrEngine/Environment.h
+++ b/src/xrEngine/Environment.h
@@ -298,6 +298,8 @@ public:
 
 	float wetness_factor;
 
+	Fvector4 wind_anim;
+
 	// wind blast params
 	float wind_blast_strength;
 	Fvector wind_blast_direction;
diff --git a/src/xrEngine/Environment_misc.cpp b/src/xrEngine/Environment_misc.cpp
index bb5c882..eca3900 100644
--- a/src/xrEngine/Environment_misc.cpp
+++ b/src/xrEngine/Environment_misc.cpp
@@ -14,6 +14,7 @@
 
 extern float ps_r2_sun_shafts_min;
 extern float ps_r2_sun_shafts_value;
+extern Fvector3 ssfx_wetness_multiplier;
 
 void CEnvModifier::load(IReader* fs, u32 version)
 {
@@ -505,9 +506,9 @@ void CEnvDescriptorMixer::lerp(CEnvironment* env, CEnvDescriptor& A, CEnvDescrip
 	sun_color.lerp(A.sun_color, B.sun_color, f);
 
 	if (rain_density > 0.f)
-		env->wetness_factor += rain_density / 10000.f;
+		env->wetness_factor += ( rain_density * ssfx_wetness_multiplier.x) / 10000.f;
 	else
-		env->wetness_factor -= 0.00001f;
+		env->wetness_factor -= 0.0001f * ssfx_wetness_multiplier.y;
 
 	clamp(env->wetness_factor, 0.f, 1.f);
 
diff --git a/src/xrEngine/IGame_Persistent.cpp b/src/xrEngine/IGame_Persistent.cpp
index b31df1e..38a21b6 100644
--- a/src/xrEngine/IGame_Persistent.cpp
+++ b/src/xrEngine/IGame_Persistent.cpp
@@ -11,6 +11,7 @@
 # include "Render.h"
 # include "ps_instance.h"
 # include "CustomHUD.h"
+# include "perlin.h"
 #endif
 
 #ifdef _EDITOR
@@ -21,6 +22,8 @@ bool g_dedicated_server = false;
 # include "editor_environment_manager.hpp"
 #endif // INGAME_EDITOR
 
+extern Fvector4 ps_ssfx_grass_interactive;
+
 ENGINE_API IGame_Persistent* g_pGamePersistent = NULL;
 
 bool IsMainMenuActive()
@@ -39,6 +42,10 @@ IGame_Persistent::IGame_Persistent()
 
 	m_pMainMenu = NULL;
 
+	PerlinNoise1D = xr_new<CPerlinNoise1D>(Random.randI(0, 0xFFFF));
+	PerlinNoise1D->SetOctaves(2);
+	PerlinNoise1D->SetAmplitude(0.66666f);
+
 #ifndef INGAME_EDITOR
 #ifndef _EDITOR
 	pEnvironment = xr_new<CEnvironment>();
@@ -53,6 +60,7 @@ IGame_Persistent::IGame_Persistent()
 
 IGame_Persistent::~IGame_Persistent()
 {
+	xr_delete(PerlinNoise1D);
 	RDEVICE.seqFrame.Remove(this);
 	RDEVICE.seqAppStart.Remove(this);
 	RDEVICE.seqAppEnd.Remove(this);
@@ -338,3 +346,305 @@ void IGame_Persistent::OnAssetsChanged()
 	Device.m_pRender->OnAssetsChanged(); //Resources->m_textures_description.Load();
 #endif
 }
+
+void IGame_Persistent::GrassBendersUpdate(u16 id, u8& data_idx, u32& data_frame, Fvector& position, float init_radius, float init_str, bool CheckDistance)
+{
+	// Interactive grass disabled
+	if (ps_ssfx_grass_interactive.y < 1)
+		return;
+
+	// Just update position if not NULL
+	if (data_idx != NULL)
+	{
+		// Explosions can take the mem spot, unassign and try to get a spot later.
+		if (grass_shader_data.id[data_idx] != id)
+		{
+			data_idx = NULL;
+			data_frame = RDEVICE.dwFrame + Random.randI(10, 35);
+		}
+		else
+		{
+			grass_shader_data.pos[data_idx] = position;
+		}
+	}
+
+	if (RDEVICE.dwFrame < data_frame)
+		return;
+
+	// Wait some random frames to split the checks
+	data_frame = RDEVICE.dwFrame + Random.randI(10, 35);
+
+	// Check Distance
+	if (CheckDistance)
+	{
+		if (position.distance_to_xz_sqr(Device.vCameraPosition) > ps_ssfx_grass_interactive.z)
+		{
+			GrassBendersRemoveByIndex(data_idx);
+			return;
+		}
+	}
+
+	CFrustum& view_frust = ::Render->ViewBase;
+	u32 mask = 0xff;
+	float rad = data_idx == NULL ? 1.0 : std::max(1.0f, grass_shader_data.radius_curr[data_idx] + 0.5f);
+
+	// In view frustum?
+	if (!view_frust.testSphere(position, rad, mask))
+	{
+		GrassBendersRemoveByIndex(data_idx);
+		return;
+	}
+
+	// Empty slot, let's use this
+	if (data_idx == NULL)
+	{
+		u8 idx = grass_shader_data.index + 1;
+
+		// Add to grass blenders array
+		if (grass_shader_data.id[idx] == NULL)
+		{
+			data_idx = idx;
+			GrassBendersSet(idx, id, position, Fvector3().set(0, -99, 0), 0, 0, 0.0f, init_radius, BENDER_ANIM_DEFAULT, true);
+
+			grass_shader_data.str_target[idx] = init_str;
+			grass_shader_data.radius_curr[idx] = init_radius;
+		}
+		// Back to 0 when the array limit is reached
+		grass_shader_data.index = idx < ps_ssfx_grass_interactive.y ? idx : 0;
+	}
+	else
+	{
+		// Already inview, let's add more time to re-check
+		data_frame += 60;
+		grass_shader_data.pos[data_idx] = position;
+	}
+}
+
+void IGame_Persistent::GrassBendersAddExplosion(u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius)
+{
+	if (ps_ssfx_grass_interactive.y < 1)
+		return;
+
+	for (int idx = 1; idx < ps_ssfx_grass_interactive.y + 1; idx++)
+	{
+		// Add explosion to any spot not already taken by an explosion.
+		if (grass_shader_data.anim[idx] != BENDER_ANIM_EXPLOSION)
+		{
+			// Add 99 to the ID to avoid conflicts between explosions and basic benders happening at the same time with the same ID.
+			GrassBendersSet(idx, id + 99, position, dir, fade, speed, intensity, radius, BENDER_ANIM_EXPLOSION, true);
+			grass_shader_data.str_target[idx] = intensity;
+			break;
+		}
+	}
+}
+
+void IGame_Persistent::GrassBendersAddShot(u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius)
+{
+	// Is disabled?
+	if (ps_ssfx_grass_interactive.y < 1 || intensity <= 0.0f)
+		return;
+
+	// Check distance
+	if (position.distance_to_xz_sqr(Device.vCameraPosition) > ps_ssfx_grass_interactive.z)
+		return;
+
+	int AddAt = -1;
+
+	// Look for a spot
+	for (int idx = 1; idx < ps_ssfx_grass_interactive.y + 1; idx++)
+	{
+		// Already exist, just update and increase intensity
+		if (grass_shader_data.id[idx] == id)
+		{
+			float currentSTR = grass_shader_data.str[idx];
+			GrassBendersSet(idx, id, position, dir, fade, speed, currentSTR, radius, BENDER_ANIM_EXPLOSION, false);
+			grass_shader_data.str_target[idx] += intensity;
+			AddAt = -1;
+			break;
+		}
+		else
+		{
+			// Check all indexes and keep usable index to use later if needed...
+			if (AddAt == -1 && grass_shader_data.radius[idx] == NULL)
+				AddAt = idx;
+		}
+	}
+
+	// We got an available index... Add bender at AddAt
+	if (AddAt != -1)
+	{
+		GrassBendersSet(AddAt, id, position, dir, fade, speed, 0.001f, radius, BENDER_ANIM_EXPLOSION, true);
+		grass_shader_data.str_target[AddAt] = intensity;
+	}
+}
+
+void IGame_Persistent::GrassBendersUpdateAnimations()
+{
+	for (int idx = 1; idx < ps_ssfx_grass_interactive.y + 1; idx++)
+	{
+		if (grass_shader_data.id[idx] != NULL)
+		{
+			switch (grass_shader_data.anim[idx])
+			{
+			case BENDER_ANIM_EXPLOSION: // Internal Only ( You can use BENDER_ANIM_PULSE for anomalies )
+			{
+				// Radius
+				grass_shader_data.time[idx] += Device.fTimeDelta * grass_shader_data.speed[idx];
+				grass_shader_data.radius_curr[idx] = grass_shader_data.radius[idx] * std::min(1.0f, grass_shader_data.time[idx]);
+
+				grass_shader_data.str_target[idx] = std::min(1.0f, grass_shader_data.str_target[idx]);
+
+				// Easing
+				float diff = abs(grass_shader_data.str[idx] - grass_shader_data.str_target[idx]);
+				diff = std::max(0.1f, diff);
+
+				// Intensity
+				if (grass_shader_data.str_target[idx] <= grass_shader_data.str[idx])
+				{
+					grass_shader_data.str[idx] -= Device.fTimeDelta * grass_shader_data.fade[idx] * diff;
+				}
+				else
+				{
+					grass_shader_data.str[idx] += Device.fTimeDelta * grass_shader_data.speed[idx] * diff;
+
+					if (grass_shader_data.str[idx] >= grass_shader_data.str_target[idx])
+						grass_shader_data.str_target[idx] = 0;
+				}
+
+				// Remove Bender
+				if (grass_shader_data.str[idx] < 0.0f)
+					GrassBendersReset(idx);
+			}
+			break;
+
+			case BENDER_ANIM_WAVY:
+			{
+				// Anim Speed
+				grass_shader_data.time[idx] += Device.fTimeDelta * 1.5f * grass_shader_data.speed[idx];
+
+				// Curve
+				float curve = sin(grass_shader_data.time[idx]);
+
+				// Intensity using curve
+				grass_shader_data.str[idx] = curve * cos(curve * 1.4f) * 1.8f * grass_shader_data.str_target[idx];
+			}
+
+			break;
+
+			case BENDER_ANIM_SUCK:
+			{
+				// Anim Speed
+				grass_shader_data.time[idx] += Device.fTimeDelta * grass_shader_data.speed[idx];
+
+				// Perlin Noise
+				float curve = clampr(PerlinNoise1D->GetContinious(grass_shader_data.time[idx]) + 0.5f, 0.f, 1.f) * -1.0;
+
+				// Intensity using Perlin
+				grass_shader_data.str[idx] = curve * grass_shader_data.str_target[idx];
+			}
+			break;
+
+			case BENDER_ANIM_BLOW:
+			{
+				// Anim Speed
+				grass_shader_data.time[idx] += Device.fTimeDelta * 1.2f * grass_shader_data.speed[idx];
+
+				// Perlin Noise
+				float curve = clampr(PerlinNoise1D->GetContinious(grass_shader_data.time[idx]) + 1.0f, 0.f, 2.0f) * 0.25f;
+
+				// Intensity using Perlin
+				grass_shader_data.str[idx] = curve * grass_shader_data.str_target[idx];
+			}
+			break;
+
+			case BENDER_ANIM_PULSE:
+			{
+				// Anim Speed
+				grass_shader_data.time[idx] += Device.fTimeDelta * grass_shader_data.speed[idx];
+
+				// Radius
+				grass_shader_data.radius_curr[idx] = grass_shader_data.radius[idx] * std::min(1.0f, grass_shader_data.time[idx]);
+
+				// Diminish intensity when radius target is reached
+				if (grass_shader_data.radius_curr[idx] >= grass_shader_data.radius[idx])
+					grass_shader_data.str[idx] += GrassBenderToValue(grass_shader_data.str[idx], 0.0f, grass_shader_data.speed[idx] * 0.6f, true);
+
+				// Loop when intensity is <= 0
+				if (grass_shader_data.str[idx] <= 0.0f)
+				{
+					grass_shader_data.str[idx] = grass_shader_data.str_target[idx];
+					grass_shader_data.radius_curr[idx] = 0.0f;
+					grass_shader_data.time[idx] = 0.0f;
+				}
+
+			}
+			break;
+
+			case BENDER_ANIM_DEFAULT:
+
+				// Just fade to target strength
+				grass_shader_data.str[idx] += GrassBenderToValue(grass_shader_data.str[idx], grass_shader_data.str_target[idx], 2.0f, true);
+
+				break;
+			}
+		}
+	}
+}
+
+void IGame_Persistent::GrassBendersRemoveByIndex(u8& idx)
+{
+	if (idx != NULL)
+	{
+		GrassBendersReset(idx);
+		idx = NULL;
+	}
+}
+
+void IGame_Persistent::GrassBendersRemoveById(u16 id)
+{
+	// Search by Object ID ( Used when removing benders CPHMovementControl::DestroyCharacter() )
+	for (int i = 1; i < ps_ssfx_grass_interactive.y + 1; i++)
+		if (grass_shader_data.id[i] == id)
+			GrassBendersReset(i);
+}
+
+void IGame_Persistent::GrassBendersReset(u8 idx)
+{
+	// Reset Everything
+	GrassBendersSet(idx, NULL, Fvector3().set(0, 0, 0), Fvector3().set(0, -99, 0), 0, 0, 0, 0, BENDER_ANIM_DEFAULT, true);
+	grass_shader_data.str_target[idx] = 0;
+}
+
+void IGame_Persistent::GrassBendersSet(u8 idx, u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius, GrassBenders_Anim anim, bool resetTime)
+{
+	// Set values
+	grass_shader_data.anim[idx] = anim;
+	grass_shader_data.pos[idx] = position;
+	grass_shader_data.id[idx] = id;
+	grass_shader_data.radius[idx] = radius;
+	grass_shader_data.str[idx] = intensity;
+	grass_shader_data.fade[idx] = fade;
+	grass_shader_data.speed[idx] = speed;
+	grass_shader_data.dir[idx] = dir;
+
+	if (resetTime)
+	{
+		grass_shader_data.radius_curr[idx] = 0.01f;
+		grass_shader_data.time[idx] = 0;
+	}
+}
+
+float IGame_Persistent::GrassBenderToValue(float& current, float go_to, float intensity, bool use_easing)
+{
+	float diff = abs(current - go_to);
+
+	float r_value = Device.fTimeDelta * intensity * (use_easing ? std::min(0.5f, diff) : 1.0f);
+
+	if (diff - r_value <= 0)
+	{
+		current = go_to;
+		return 0;
+	}
+
+	return current < go_to ? r_value : -r_value;
+}
diff --git a/src/xrEngine/IGame_Persistent.h b/src/xrEngine/IGame_Persistent.h
index a39152f..9a88fc8 100644
--- a/src/xrEngine/IGame_Persistent.h
+++ b/src/xrEngine/IGame_Persistent.h
@@ -64,6 +64,44 @@ public:
 	xr_set<CPS_Instance*> ps_active;
 	xr_vector<CPS_Instance*> ps_destroy;
 	xr_vector<CPS_Instance*> ps_needtoplay;
+public:
+	enum GrassBenders_Anim
+	{
+		BENDER_ANIM_EXPLOSION = 0,
+		BENDER_ANIM_DEFAULT = 1,
+		BENDER_ANIM_WAVY = 2,
+		BENDER_ANIM_SUCK = 3,
+		BENDER_ANIM_BLOW = 4,
+		BENDER_ANIM_PULSE = 5,
+	}; 
+
+	void GrassBendersUpdateAnimations();
+	void GrassBendersAddExplosion(u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius);
+	void GrassBendersAddShot(u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius);
+	void GrassBendersRemoveById(u16 id);
+	void GrassBendersRemoveByIndex(u8& idx);
+	void GrassBendersUpdate(u16 id, u8& data_idx, u32& data_frame, Fvector& position, float radius, float str, bool CheckDistance );
+	void GrassBendersReset(u8 idx);
+	void GrassBendersSet(u8 idx, u16 id, Fvector position, Fvector3 dir, float fade, float speed, float str, float radius, GrassBenders_Anim anim, bool resetTime);
+	float GrassBenderToValue(float& current, float go_to, float intensity, bool use_easing);
+
+	CPerlinNoise1D* PerlinNoise1D;
+
+	struct grass_data
+	{
+		u8 index;
+		s8 anim[16];
+		u16 id[16];
+		Fvector pos[16];
+		Fvector3 dir[16];
+		float radius[16];
+		float radius_curr[16];
+		float str[16];
+		float str_target[16];
+		float time[16];
+		float fade[16];
+		float speed[16];
+	} grass_shader_data;
 
 public:
 	void destroy_particles(const bool& all_particles);
diff --git a/src/xrEngine/Rain.cpp b/src/xrEngine/Rain.cpp
index b4de67e..53f4965 100644
--- a/src/xrEngine/Rain.cpp
+++ b/src/xrEngine/Rain.cpp
@@ -5,6 +5,8 @@
 #include "igame_persistent.h"
 #include "environment.h"
 
+#include "../../xrEngine/perlin.h"
+
 #ifdef _EDITOR
 #include "ui_toolscustom.h"
 #else
@@ -17,13 +19,13 @@
 // Warning: duplicated in dxRainRender
 static const int max_desired_items = 2500;
 static const float source_radius = 12.5f;
-static const float source_offset = 40.f;
-static const float max_distance = source_offset * 1.25f;
+static const float source_offset = 20.f; // 40
+static const float max_distance = source_offset * 1.5f;//1.25f;
 static const float sink_offset = -(max_distance - source_offset);
 static const float drop_length = 5.f;
 static const float drop_width = 0.30f;
-static const float drop_angle = 3.0f;
-static const float drop_max_angle = deg2rad(10.f);
+static const float drop_angle = deg2rad(15.0f); // 3.0
+static const float drop_max_angle = deg2rad(35.f); // 10
 static const float drop_max_wind_vel = 20.0f;
 static const float drop_speed_min = 40.f;
 static const float drop_speed_max = 80.f;
@@ -32,6 +34,8 @@ const int max_particles = 1000;
 const int particles_cache = 400;
 const float particles_time = .3f;
 
+CPerlinNoise1D* RainPerlin;
+
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -43,6 +47,10 @@ CEffect_Rain::CEffect_Rain()
 	snd_Ambient.create("ambient\\rain", st_Effect, sg_Undefined);
 	rain_volume = 0.0f;
 
+	RainPerlin = xr_new<CPerlinNoise1D>(Random.randI(0, 0xFFFF));
+	RainPerlin->SetOctaves(2);
+	RainPerlin->SetAmplitude(0.66666f);
+
 	// Moced to p_Render constructor
 	/*
 	IReader* F = FS.r_open("$game_meshes$","dm\\rain.dm");
@@ -60,6 +68,7 @@ CEffect_Rain::CEffect_Rain()
 
 CEffect_Rain::~CEffect_Rain()
 {
+	xr_delete(RainPerlin);
 	snd_Ambient.destroy();
 	rain_volume = 0.0f;
 
@@ -69,28 +78,67 @@ CEffect_Rain::~CEffect_Rain()
 	//::Render->model_Delete (DM_Drop);
 }
 
+void CEffect_Rain::Prepare(Fvector2& offset, Fvector3& axis, float W_Velocity, float W_Direction)
+{
+	// Wind gust, to add variation.
+	float Wind_Gust = RainPerlin->GetContinious(Device.fTimeGlobal * 0.3f) * 2.0f;
+
+	// Wind velocity [ 0 ~ 1 ]
+	float Wind_Velocity = W_Velocity + Wind_Gust;
+
+	clamp(Wind_Velocity, 0.0f, 1.0f);
+
+	// Wind velocity controles the angle
+	float pitch = drop_max_angle * Wind_Velocity;
+	axis.setHP(W_Direction, pitch - PI_DIV_2);
+
+	// Get distance
+	float dist = _sin(pitch) * source_offset;
+	float C = PI_DIV_2 - pitch;
+	dist /= _sin(C);
+
+	// 0 is North
+	float fixNorth = W_Direction - PI_DIV_2;
+
+	// Set offset
+	offset.set(dist * _cos(fixNorth), dist * _sin(fixNorth));
+}
+
 // Born
-void CEffect_Rain::Born(Item& dest, float radius)
+void CEffect_Rain::Born(Item& dest, float radius, float speed)
 {
-	Fvector axis;
-	axis.set(0, -1, 0);
-	float gust = g_pGamePersistent->Environment().wind_strength_factor / 10.f;
-	float k = g_pGamePersistent->Environment().CurrentEnv->wind_velocity * gust / drop_max_wind_vel;
-	clamp(k, 0.f, 1.f);
-	float pitch = drop_max_angle * k - PI_DIV_2;
-	axis.setHP(g_pGamePersistent->Environment().CurrentEnv->wind_direction, pitch);
+	// Prepare correct angle and distance to hit the player
+	Fvector Rain_Axis = { 0, -1, 0 };
+	Fvector2 Rain_Offset;
+
+	float Wind_Direction = -g_pGamePersistent->Environment().CurrentEnv->wind_direction;
+
+	// Wind Velocity [ From 0 ~ 1000 to 0 ~ 1 ]
+	float Wind_Velocity = g_pGamePersistent->Environment().CurrentEnv->wind_velocity * 0.001f;
+	clamp(Wind_Velocity, 0.0f, 1.0f);
 
+	Prepare(Rain_Offset, Rain_Axis, Wind_Velocity, Wind_Direction);
+
+	// Camera Position
 	Fvector& view = Device.vCameraPosition;
-	float angle = ::Random.randF(0, PI_MUL_2);
-	float dist = ::Random.randF();
-	dist = _sqrt(dist) * radius;
-	float x = dist * _cos(angle);
-	float z = dist * _sin(angle);
-	dest.D.random_dir(axis, deg2rad(drop_angle));
-	dest.P.set(x + view.x - dest.D.x * source_offset, source_offset + view.y, z + view.z - dest.D.z * source_offset);
-	// dest.P.set (x+view.x,height+view.y,z+view.z);
-	dest.fSpeed = ::Random.randF(drop_speed_min, drop_speed_max);
 
+	// Random Position
+	float r = radius * 0.5f;
+	Fvector2 RandomP = { ::Random.randF(-r, r), ::Random.randF(-r, r) };
+
+	// Aim ahead of where the player is facing
+	Fvector FinalView = Fvector().mad(view, Device.vCameraDirection, 5.0f);
+
+	// Random direction. Higher angle at lower velocity
+	dest.D.random_dir(Rain_Axis, ::Random.randF(-drop_angle, drop_angle) * (1.5f - Wind_Velocity));
+
+	// Set final destination
+	dest.P.set(Rain_Offset.x + FinalView.x + RandomP.x, source_offset + view.y, Rain_Offset.y + FinalView.z + RandomP.y);
+
+	// Set speed
+	dest.fSpeed = ::Random.randF(drop_speed_min, drop_speed_max) * speed * clampr(Wind_Velocity * 1.5f, 0.5f, 1.0f);
+
+	// Born
 	float height = max_distance;
 	RenewItem(dest, height, RayPick(dest.P, dest.D, height, collide::rqtBoth));
 }
@@ -137,7 +185,14 @@ void CEffect_Rain::OnFrame()
 #endif
 
 	// Parse states
-	float factor = g_pGamePersistent->Environment().CurrentEnv->rain_density;
+	float rain_density = g_pGamePersistent->Environment().CurrentEnv->rain_density;
+	float wind_velocity = g_pGamePersistent->Environment().CurrentEnv->wind_velocity * 0.001f;
+	clamp(wind_velocity, 0.0f, 1.0f);
+	
+	wind_velocity *= (rain_density > 0.0f ? 1.0f : 0.0f); // Only when raining
+
+	// 50% of the volume is by rain_density and 50% wind_velocity;
+	float factor = rain_density * 0.5f + wind_velocity * 0.5f;
 	static float hemi_factor = 0.f;
 #ifndef _EDITOR
 	CObject* E = g_pGameLevel->CurrentViewEntity();
@@ -155,6 +210,7 @@ void CEffect_Rain::OnFrame()
 		float t = Device.fTimeDelta;
 		clamp(t, 0.001f, 1.0f);
 		hemi_factor = hemi_factor * (1.0f - t) + f * t;
+		rain_hemi = hemi_val;
 	}
 #endif
 
diff --git a/src/xrEngine/Rain.h b/src/xrEngine/Rain.h
index 7f59021..c95167e 100644
--- a/src/xrEngine/Rain.h
+++ b/src/xrEngine/Rain.h
@@ -74,6 +74,7 @@ private:
 	// Sounds
 	ref_sound snd_Ambient;
 	float rain_volume;
+	float rain_hemi = 0.0f;
 
 	// Utilities
 	void p_create();
@@ -86,10 +87,11 @@ private:
 	void p_free(Particle* P);
 
 	// Some methods
-	void Born(Item& dest, float radius);
+	void Born(Item& dest, float radius, float speed);
 	void Hit(Fvector& pos);
 	BOOL RayPick(const Fvector& s, const Fvector& d, float& range, collide::rq_target tgt);
 	void RenewItem(Item& dest, float height, BOOL bHit);
+	void Prepare(Fvector2& offset, Fvector3& axis, float Wind_Vel, float Wind_Dir);
 public:
 	CEffect_Rain();
 	~CEffect_Rain();
@@ -105,6 +107,7 @@ public:
 	}
 
 	float GetRainVolume() { return rain_volume; }
+	float GetRainHemi() { return rain_hemi; }
 };
 
 #endif //RainH
diff --git a/src/xrEngine/Render.h b/src/xrEngine/Render.h
index df52521..414398d 100644
--- a/src/xrEngine/Render.h
+++ b/src/xrEngine/Render.h
@@ -212,6 +212,7 @@ public:
 
 public:
 	// options
+	bool hud_loading;
 	s32 m_skinning;
 	s32 m_MSAASample;
 
diff --git a/src/xrEngine/bone.h b/src/xrEngine/bone.h
index 1a8472c..4348fd7 100644
--- a/src/xrEngine/bone.h
+++ b/src/xrEngine/bone.h
@@ -29,6 +29,8 @@ public:
 	// data
 	Fmatrix mTransform; // final x-form matrix (local to model)
 	Fmatrix mRenderTransform; // final x-form matrix (model_base -> bone -> model)
+	Fmatrix mRenderTransform_prev; // Prev x-form matrix
+	Fmatrix mRenderTransform_temp; // Temp var
 private:
 	BoneCallback Callback;
 	void* Callback_Param;
@@ -599,6 +601,9 @@ IC void CBoneInstance::construct()
 	mTransform.identity();
 
 	mRenderTransform.identity();
+	mRenderTransform_prev.identity();
+	mRenderTransform_temp.identity();
+
 	Callback_overwrite = FALSE;
 }
 
diff --git a/src/xrEngine/xr_ioc_cmd.cpp b/src/xrEngine/xr_ioc_cmd.cpp
index a1ec515..3539662 100644
--- a/src/xrEngine/xr_ioc_cmd.cpp
+++ b/src/xrEngine/xr_ioc_cmd.cpp
@@ -864,6 +864,8 @@ Ivector4 g_crosshair_color_temp;
 float g_freelook_z_offset;
 float g_ironsights_factor = 1.25f;
 
+Fvector3 ssfx_wetness_multiplier = Fvector3().set(1.0f, 0.3f, 0.0f);
+
 void CCC_Register()
 {
 	// General
@@ -1023,6 +1025,7 @@ void CCC_Register()
 		CMD4(CCC_Float, "g_freelook_z_offset_factor", &g_freelook_z_offset, -3.f, 3.f);
 
 	CMD4(CCC_Float, "g_ironsights_zoom_factor", &g_ironsights_factor, 1.f, 2.f);
+	CMD4(CCC_Vector3, "ssfx_wetness_multiplier", &ssfx_wetness_multiplier, Fvector3().set(0.1f, 0.1f, 0.0f), Fvector3().set(20.0f, 20.0f, 0.0f));
 	
 #ifdef DEBUG
     extern BOOL debug_destroy;
diff --git a/src/xrGame/CustomZone.cpp b/src/xrGame/CustomZone.cpp
index ff568cd..7d83a8d 100644
--- a/src/xrGame/CustomZone.cpp
+++ b/src/xrGame/CustomZone.cpp
@@ -22,6 +22,8 @@
 #define WIND_RADIUS (4*Radius())	//расстояние до актера, когда появляется ветер 
 #define FASTMODE_DISTANCE (100.f)	//distance to camera from sphere, when zone switches to fast update sequence
 
+extern Fvector4 ps_ssfx_int_grass_params_1;
+
 CCustomZone::CCustomZone(void)
 {
 	m_zone_flags.zero();
@@ -59,6 +61,7 @@ CCustomZone::CCustomZone(void)
 
 CCustomZone::~CCustomZone(void)
 {
+	g_pGamePersistent->GrassBendersRemoveByIndex(grassbender_id);
 	m_idle_sound.destroy();
 	m_accum_sound.destroy();
 	m_awaking_sound.destroy();
@@ -96,6 +99,59 @@ void CCustomZone::Load(LPCSTR section)
 
 	LPCSTR sound_str = NULL;
 
+	// -- Interactive Grass - IDLE
+	if (pSettings->line_exist(section, "bend_grass_idle_anim"))
+		m_BendGrass_idle_anim = pSettings->r_s8(section, "bend_grass_idle_anim");
+	else
+		m_BendGrass_idle_anim = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_idle_str"))
+		m_BendGrass_idle_str = pSettings->r_float(section, "bend_grass_idle_str");
+	else
+		m_BendGrass_idle_str = 1.0f;
+
+	if (pSettings->line_exist(section, "bend_grass_idle_radius"))
+		m_BendGrass_idle_radius = pSettings->r_float(section, "bend_grass_idle_radius");
+	else
+		m_BendGrass_idle_radius = 1.0f;
+
+	if (pSettings->line_exist(section, "bend_grass_idle_speed"))
+		m_BendGrass_idle_speed = pSettings->r_float(section, "bend_grass_idle_speed");
+	else
+		m_BendGrass_idle_speed = 1.0f;
+
+	// -- Interactive Grass - ACTIVE
+	if (pSettings->line_exist(section, "bend_grass_whenactive_anim"))
+		m_BendGrass_whenactive_anim = pSettings->r_s8(section, "bend_grass_whenactive_anim");
+	else
+		m_BendGrass_whenactive_anim = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_whenactive_speed"))
+		m_BendGrass_whenactive_speed = pSettings->r_float(section, "bend_grass_whenactive_speed");
+	else
+		m_BendGrass_whenactive_speed = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_whenactive_str"))
+		m_BendGrass_whenactive_str = pSettings->r_float(section, "bend_grass_whenactive_str");
+	else
+		m_BendGrass_whenactive_str = -1;
+
+	// -- Interactive Grass - BLOWOUT
+	if (pSettings->line_exist(section, "bend_grass_blowout_duration"))
+		m_BendGrass_Blowout_time = pSettings->r_u32(section, "bend_grass_blowout_duration");
+	else
+		m_BendGrass_Blowout_time = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_blowout"))
+		m_BendGrass_Blowout = pSettings->r_bool(section, "bend_grass_blowout");
+
+	if (pSettings->line_exist(section, "bend_grass_blowout_speed"))
+		m_BendGrass_Blowout_speed = pSettings->r_float(section, "bend_grass_blowout_speed");
+
+	if (pSettings->line_exist(section, "bend_grass_blowout_radius"))
+		m_BendGrass_Blowout_radius = pSettings->r_float(section, "bend_grass_blowout_radius");
+	// --
+
 	if (pSettings->line_exist(section, "idle_sound"))
 	{
 		sound_str = pSettings->r_string(section, "idle_sound");
@@ -582,6 +638,31 @@ void CCustomZone::shedule_Update(u32 dt)
 
 		if (!m_zone_flags.test(eFastMode))
 			UpdateWorkload(dt);
+
+		if (act_distance < ps_ssfx_int_grass_params_1.w)
+			GrassZoneUpdate();
+		else
+		{
+			// Out of range, fadeOut if a grassbender_id is assigned
+			if (grassbender_id)
+			{
+				IGame_Persistent::grass_data& GData = g_pGamePersistent->grass_shader_data;
+
+				// If the ID doesn't match... Just remove the grassbender_id.
+				if (GData.id[grassbender_id] == ID())
+				{
+					GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], 0.0f, 4.0f, false);
+
+					// Remove ( Don't worry, GrassBenderToValue() it's going to get the == 0 )
+					if (GData.str_target[grassbender_id] == 0)
+						g_pGamePersistent->GrassBendersRemoveByIndex(grassbender_id);
+				}
+				else
+				{
+					grassbender_id = NULL;
+				}
+			}
+		}
 	};
 
 	UpdateOnOffState();
@@ -786,6 +867,8 @@ void CCustomZone::PlayBlowoutParticles()
 	pParticles = CParticlesObject::Create(*m_sBlowoutParticles,TRUE);
 	pParticles->UpdateParent(XFORM(), zero_vel);
 	pParticles->Play(false);
+
+	m_fBlowoutTimeLeft = (float)Device.dwTimeGlobal + m_BendGrass_Blowout_time;
 }
 
 void CCustomZone::PlayHitParticles(CGameObject* pObject)
@@ -1125,6 +1208,9 @@ void CCustomZone::UpdateBlowout()
 		m_dwBlowoutExplosionTime < (u32)m_iStateTime)
 	{
 		AffectObjects();
+		
+		if (m_BendGrass_Blowout)
+			g_pGamePersistent->GrassBendersAddExplosion(ID(), Position(), Fvector().set(0, -99, 0), 1.33f, m_BendGrass_Blowout_speed, 1.0f, m_BendGrass_Blowout_radius);
 	}
 }
 
@@ -1158,6 +1244,13 @@ void CCustomZone::OnMove()
 
 		if (m_pIdleLight && m_pIdleLight->get_active())
 			m_pIdleLight->set_position(Position());
+
+		if (grassbender_id)
+		{
+			// Check ID, just in case...
+			if (g_pGamePersistent->grass_shader_data.id[grassbender_id] == ID())
+				g_pGamePersistent->grass_shader_data.pos[grassbender_id] = Position();
+		}
 	}
 }
 
@@ -1597,3 +1690,61 @@ void CCustomZone::load(IReader& input_packet)
 	else
 		m_eZoneState = eZoneStateIdle;
 }
+
+void CCustomZone::GrassZoneUpdate()
+{
+	if (m_BendGrass_idle_anim == -1 && m_BendGrass_whenactive_anim == -1)
+		return;
+
+	IGame_Persistent::grass_data& GData = g_pGamePersistent->grass_shader_data;
+	bool IsActive;
+	s8 targetAnim = -1;
+
+	// If m_BendGrass_Blowout_time is not set, use m_eZoneState to detect activation
+	if (m_BendGrass_Blowout_time <= -1)
+		IsActive = m_eZoneState != eZoneStateIdle;
+	else
+		IsActive = m_fBlowoutTimeLeft > (float)Device.dwTimeGlobal;
+
+	// Target animation depending if Zone is active
+	if (IsActive)
+		targetAnim = (m_BendGrass_whenactive_anim > -1) ? m_BendGrass_whenactive_anim : m_BendGrass_idle_anim;
+	else
+		targetAnim = m_BendGrass_idle_anim;
+
+	// Update grass bender if the animation is > -1
+	if (targetAnim > 0 || (grassbender_id > 0 && GData.anim[grassbender_id] > 0))
+		g_pGamePersistent->GrassBendersUpdate(ID(), grassbender_id, grassbender_frame, Position(), m_BendGrass_idle_radius, 0.0f, false);
+	else
+		g_pGamePersistent->GrassBendersRemoveByIndex(grassbender_id);
+
+	// Return if grassbender_id doesn't exist
+	if (grassbender_id <= 0)
+		return;
+
+	// Animation transition, diminish intensity to 0 and change.
+	if (GData.anim[grassbender_id] != targetAnim)
+	{
+		GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], 0.0f, 7.5f, false);
+
+		if (GData.str_target[grassbender_id] <= 0.05f)
+			GData.anim[grassbender_id] = targetAnim;
+
+		return;
+	}
+
+	// Apply settings when needed
+	if (IsActive)
+	{
+		if (m_BendGrass_whenactive_speed >= 0)
+			GData.speed[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.speed[grassbender_id], m_BendGrass_whenactive_speed, 10.0f, true);
+
+		if (m_BendGrass_whenactive_str >= 0)
+			GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], m_BendGrass_whenactive_str, 10.0f, true);
+	}
+	else
+	{
+		GData.speed[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.speed[grassbender_id], m_BendGrass_idle_speed, 10.0f, true);
+		GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], m_BendGrass_idle_str, 10.0f, true);
+	}
+}
diff --git a/src/xrGame/CustomZone.h b/src/xrGame/CustomZone.h
index 3baa654..eca8679 100644
--- a/src/xrGame/CustomZone.h
+++ b/src/xrGame/CustomZone.h
@@ -159,6 +159,28 @@ protected:
 	float volumetric_intensity;
 	float volumetric_quality;
 
+	// Interactive grass Settings
+	float m_fBlowoutTimeLeft;
+
+	s8 m_BendGrass_idle_anim;
+	float m_BendGrass_idle_radius;
+	float m_BendGrass_idle_speed;
+	float m_BendGrass_idle_str;
+
+	s8 m_BendGrass_whenactive_anim;
+	float m_BendGrass_whenactive_speed;
+	float m_BendGrass_whenactive_str;
+
+	bool m_BendGrass_Blowout;
+	s32 m_BendGrass_Blowout_time;
+	float m_BendGrass_Blowout_speed;
+	float m_BendGrass_Blowout_radius;
+
+	u8 grassbender_id;
+	u32 grassbender_frame;
+
+	void GrassZoneUpdate();
+
 	//массив с временами, сколько каждое состояние должно 
 	//длиться (если 0, то мгновенно -1 - бесконечность, 
 	//-2 - вообще не должно вызываться)
diff --git a/src/xrGame/Explosive.cpp b/src/xrGame/Explosive.cpp
index ef648e9..4154e12 100644
--- a/src/xrGame/Explosive.cpp
+++ b/src/xrGame/Explosive.cpp
@@ -341,6 +341,11 @@ void CExplosive::Explode()
 		DBG_DrawPoint(pos,0.3f,D3DCOLOR_XRGB(255,0,0));
 	}
 #endif
+	
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_int_grass_params_2;
+	g_pGamePersistent->GrassBendersAddExplosion(cast_game_object()->ID(), pos, Fvector().set(0, -99, 0), 1.33f, ps_ssfx_int_grass_params_2.y, ps_ssfx_int_grass_params_2.x, m_fBlastRadius * 2.0f);
+	
 	//	Msg("---------CExplosive Explode [%d] frame[%d]",cast_game_object()->ID(), Device.dwFrame);
 	OnBeforeExplosion();
 	//играем звук взрыва
diff --git a/src/xrGame/PHMovementControl.cpp b/src/xrGame/PHMovementControl.cpp
index 7836b3c..b8be9d8 100644
--- a/src/xrGame/PHMovementControl.cpp
+++ b/src/xrGame/PHMovementControl.cpp
@@ -1125,6 +1125,11 @@ void CPHMovementControl::PHReleaseObject()
 void CPHMovementControl::DestroyCharacter()
 {
 	VERIFY(m_character);
+
+	// Remove Grass bender if PHCharacter is not NULL
+	if (m_character->PhysicsRefObject() != NULL)
+		g_pGamePersistent->GrassBendersRemoveById(m_character->PhysicsRefObject()->ObjectID());
+
 	m_character->Destroy();
 	phcapture_destroy(m_capture);
 	//xr_delete(m_capture);
diff --git a/src/xrGame/Torch.cpp b/src/xrGame/Torch.cpp
index aabc262..4cf9b8d 100644
--- a/src/xrGame/Torch.cpp
+++ b/src/xrGame/Torch.cpp
@@ -213,6 +213,8 @@ void CTorch::LoadLightParams()
 
 		if (!pSettings->section_exist(light_definition.c_str()))
 			light_definition = *m_light_section;
+
+		light_render->set_hud_mode(true); // Enable HUD flag to player headlamp
 	}
 
 	IKinematics* K = smart_cast<IKinematics*>(Visual());
diff --git a/src/xrGame/WeaponFire.cpp b/src/xrGame/WeaponFire.cpp
index 39bbeda..60f4e8c 100644
--- a/src/xrGame/WeaponFire.cpp
+++ b/src/xrGame/WeaponFire.cpp
@@ -130,6 +130,10 @@ void CWeapon::FireTrace(const Fvector& P, const Fvector& D)
 	if (m_bLightShotEnabled)
 		Light_Start();
 
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_int_grass_params_2;
+	Fvector ShotPos = Fvector().mad(P, D, 1.5f);
+	g_pGamePersistent->GrassBendersAddShot(cast_game_object()->ID(), ShotPos, D, 3.0f, 20.0f, ps_ssfx_int_grass_params_2.z, ps_ssfx_int_grass_params_2.w);
 
 	// Ammo
 	m_lastCartridge = l_cartridge;
diff --git a/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h b/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h
index 59ffe28..a25205f 100644
--- a/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h
+++ b/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h
@@ -138,4 +138,8 @@ void CStateBurerAttackGravi<Object>::ExecuteGraviFire()
 
 	object->StopGraviPrepare();
 	object->sound().play(CBurer::eMonsterSoundGraviAttack);
+
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_grass_interactive;
+	g_pGamePersistent->GrassBendersAddExplosion(object->ID(), from_pos, object->Direction(), 1.33f, 3.0f, ps_ssfx_grass_interactive.w, 13.0f);
 }
diff --git a/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp b/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
index 908d83f..bf77ebd 100644
--- a/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
+++ b/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
@@ -291,6 +291,10 @@ void CPseudoGigant::on_threaten_execute()
 	pos.y += 0.1f;
 	m_sound_threaten_hit.play_at_pos(this, pos);
 
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_grass_interactive;
+	g_pGamePersistent->GrassBendersAddExplosion(ID(), pos, Fvector().set(0, -99, 0), 1.33f, 5.0f, ps_ssfx_grass_interactive.w, 20);
+
 	// играть партиклы
 	PlayParticles(m_kick_particles, pos, Direction());
 
diff --git a/src/xrGame/level_script.cpp b/src/xrGame/level_script.cpp
index c16d21c..162b636 100644
--- a/src/xrGame/level_script.cpp
+++ b/src/xrGame/level_script.cpp
@@ -279,6 +279,36 @@ float rain_factor()
 	return (g_pGamePersistent->Environment().CurrentEnv->rain_density);
 }
 
+float rain_wetness()
+{
+	return (g_pGamePersistent->Environment().wetness_factor);
+}
+
+float rain_hemi()
+{
+	CEffect_Rain* rain = g_pGamePersistent->pEnvironment->eff_Rain;
+
+	if (rain)
+	{
+		return rain->GetRainHemi();
+	}
+	else
+	{
+		CObject* E = g_pGameLevel->CurrentViewEntity();
+		if (E && E->renderable_ROS())
+		{
+			float* hemi_cube = E->renderable_ROS()->get_luminocity_hemi_cube();
+			float hemi_val = _max(hemi_cube[0], hemi_cube[1]);
+			hemi_val = _max(hemi_val, hemi_cube[2]);
+			hemi_val = _max(hemi_val, hemi_cube[3]);
+			hemi_val = _max(hemi_val, hemi_cube[5]);
+
+			return hemi_val;
+		}
+		return 0;
+	}
+}
+
 u32 vertex_in_direction(u32 level_vertex_id, Fvector direction, float max_distance)
 {
 	if (!ai().level_graph().valid_vertex_id(level_vertex_id))
@@ -970,7 +1000,7 @@ void set_weather_value_numric(LPCSTR name, float val)
 	else if (0 == xr_strcmp(name, "wind_velocity"))
 		E.wind_velocity = val;
 	else if (0 == xr_strcmp(name, "wind_direction"))
-		E.wind_direction = val;
+		E.wind_direction = deg2rad(val);
 	else if (0 == xr_strcmp(name, "sun_shafts_intensity"))
 	{
 		E.m_fSunShaftsIntensity = val;
@@ -1661,6 +1691,8 @@ void CLevel::script_register(lua_State* L)
 			def("low_cover_in_direction", low_cover_in_direction),
 			def("vertex_in_direction", vertex_in_direction),
 			def("rain_factor", rain_factor),
+			def("rain_wetness", rain_wetness),
+			def("rain_hemi", rain_hemi),
 			def("patrol_path_exists", patrol_path_exists),
 			def("vertex_position", vertex_position),
 			def("name", get_name),
diff --git a/src/xrGame/movement_manager.cpp b/src/xrGame/movement_manager.cpp
index 117d30d..59769bd 100644
--- a/src/xrGame/movement_manager.cpp
+++ b/src/xrGame/movement_manager.cpp
@@ -373,6 +373,9 @@ void CMovementManager::on_frame(CPHMovementControl* movement_control, Fvector& d
 		update_path();
 
 	move_along_path(movement_control, dest_position, object().client_update_fdelta());
+
+	// Update Grass benders
+	g_pGamePersistent->GrassBendersUpdate(object().ID(), grassbender_id, grassbender_frame, object().Position(), -1.0f, 1.0f, true);
 }
 
 void CMovementManager::on_travel_point_change(const u32& previous_travel_point_index)
diff --git a/src/xrGame/movement_manager.h b/src/xrGame/movement_manager.h
index 2427493..4f7fe8b 100644
--- a/src/xrGame/movement_manager.h
+++ b/src/xrGame/movement_manager.h
@@ -84,6 +84,10 @@ class CDetailPathBuilder;
 
 class CMovementManager
 {
+public:
+	u8 grassbender_id;
+	u32 grassbender_frame;
+
 private:
 	friend class CLevelPathBuilder;
 	friend class CDetailPathBuilder;
diff --git a/src/xrGame/player_hud.cpp b/src/xrGame/player_hud.cpp
index 96fae36..ec89e92 100644
--- a/src/xrGame/player_hud.cpp
+++ b/src/xrGame/player_hud.cpp
@@ -400,7 +400,9 @@ void attachable_hud_item::load(const shared_str& sect_name)
 
 	// Visual
 	LPCSTR visual_name = pSettings->r_string(sect_name, "item_visual");
+	::Render->hud_loading = true;
 	IKinematicsAnimated* visual = ::Render->model_Create(visual_name)->dcast_PKinematicsAnimated();
+	::Render->hud_loading = false;
 	R_ASSERT2(visual, make_string("could not create model %s", visual_name));
 	m_model = smart_cast<IKinematics*>(visual);
 
@@ -624,10 +626,12 @@ void player_hud::load(const shared_str& player_hud_sect, bool force)
 	}
 
 	const shared_str& model_name = pSettings->r_string(player_hud_sect, "visual");
+	::Render->hud_loading = true;
 	m_model = smart_cast<IKinematicsAnimated*>(::Render->model_Create(model_name.c_str()));
 	m_model_2 = smart_cast<IKinematicsAnimated*>(::Render->model_Create(pSettings->line_exist(player_hud_sect, "visual_2") ? pSettings->r_string(player_hud_sect, "visual_2") : model_name.c_str()));
 	bool b_reload = (m_attached_items[0] != nullptr || m_attached_items[1] != nullptr);
 
+	::Render->hud_loading = false;
 	u16 l_arm = m_model->dcast_PKinematics()->LL_BoneID("l_clavicle");
 	u16 r_arm = m_model_2->dcast_PKinematics()->LL_BoneID("r_clavicle");
 
@@ -1315,7 +1319,9 @@ u32 player_hud::script_anim_play(u8 hand, LPCSTR section, LPCSTR anm_name, bool
 
 	if (pSettings->line_exist(section, "item_visual"))
 	{
+		::Render->hud_loading = true;
 		script_anim_item_model = ::Render->model_Create(pSettings->r_string(section, "item_visual"))->dcast_PKinematicsAnimated();
+		::Render->hud_loading = false;
 		item_pos[0] = READ_IF_EXISTS(pSettings, r_fvector3, section, "item_position", def);
 		item_pos[1] = READ_IF_EXISTS(pSettings, r_fvector3, section, "item_orientation", def);
 		script_anim_item_attached = READ_IF_EXISTS(pSettings, r_bool, section, "item_attached", true);
